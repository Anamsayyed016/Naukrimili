name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    env:
      HOST: ${{ secrets.HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
      GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
      GOOGLE_CLOUD_API_KEY: ${{ secrets.GOOGLE_CLOUD_API_KEY }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      GITHUB_ID: ${{ secrets.GITHUBID }}
      GITHUB_SECRET: ${{ secrets.GITHUBSECRET }}
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Build and bundle
        env:
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          NEXT_TYPESCRIPT_IGNORE: 1
          ESLINT_NO_DEV_ERRORS: true
          NODE_OPTIONS: --max-old-space-size=4096
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: https://naukrimili.com
          NEXT_PUBLIC_APP_URL: https://naukrimili.com
        run: |
          # IMPORTANT: Don't set NODE_ENV=production during install (it skips devDependencies)
          # Clean everything for fresh install
          echo "üßπ Cleaning npm cache and existing artifacts..."
          npm cache clean --force
          rm -rf node_modules package-lock.json .npm
          
          # Verify TypeScript is in package.json
          echo "üìã Verifying TypeScript in package.json..."
          if ! grep -q '"typescript"' package.json; then
            echo "‚ùå TypeScript not found in package.json!"
            exit 1
          fi
          echo "‚úÖ TypeScript found in package.json devDependencies"
          
          # Install ALL dependencies (including devDependencies - TypeScript is needed for build)
          echo "üì¶ Installing all dependencies (devDependencies included)..."
          npm install --legacy-peer-deps --no-audit --engine-strict=false
          
          # Verify TypeScript was installed
          if [ ! -f "node_modules/typescript/package.json" ]; then
            echo "‚ùå TypeScript not installed, attempting explicit install..."
            npm install typescript@^5.9.2 --save-dev --legacy-peer-deps --no-audit --engine-strict=false --force
          fi
          
          # Final verification
          if [ -f "node_modules/typescript/package.json" ]; then
            TSC_VERSION=$(grep '"version"' node_modules/typescript/package.json | head -1)
            echo "‚úÖ TypeScript installed: $TSC_VERSION"
          else
            echo "‚ùå CRITICAL: TypeScript installation failed"
            exit 1
          fi
          
          # Validate DATABASE_URL before Prisma operations
          echo "üîç Validating DATABASE_URL..."
          if [ -z "$DATABASE_URL" ]; then
            echo "‚ùå CRITICAL: DATABASE_URL is not set or empty"
            echo ""
            echo "üìã How to fix:"
            echo "1. Go to GitHub Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Add or update DATABASE_URL secret"
            echo "3. Format: postgresql://username:password@host:port/database"
            echo "4. Example: postgresql://user:pass@localhost:5432/naukrimili"
            exit 1
          fi
          
          # Trim whitespace and remove quotes (handle potential leading/trailing spaces or quotes)
          DATABASE_URL=$(echo "$DATABASE_URL" | xargs | sed "s/^['\"]//; s/['\"]$//")
          
          # Check if DATABASE_URL is still empty after trimming
          if [ -z "$DATABASE_URL" ]; then
            echo "‚ùå CRITICAL: DATABASE_URL is empty after trimming whitespace/quotes"
            echo "‚ö†Ô∏è  Please check GitHub Secrets ‚Üí DATABASE_URL"
            exit 1
          fi
          
          # Check if DATABASE_URL starts with correct protocol (more robust check)
          DB_PROTOCOL=$(echo "$DATABASE_URL" | cut -d':' -f1)
          if [ "$DB_PROTOCOL" != "postgresql" ] && [ "$DB_PROTOCOL" != "postgres" ]; then
            echo "‚ùå CRITICAL: DATABASE_URL must start with 'postgresql://' or 'postgres://'"
            echo "üìã Current DATABASE_URL starts with: '$DB_PROTOCOL'"
            echo "üìã First 50 characters: ${DATABASE_URL:0:50}"
            echo "üìã DATABASE_URL length: ${#DATABASE_URL} characters"
            echo ""
            echo "üìã How to fix:"
            echo "1. Go to GitHub Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Update DATABASE_URL secret"
            echo "3. Ensure it starts with 'postgresql://' or 'postgres://'"
            echo "4. Format: postgresql://username:password@host:port/database"
            echo "5. Example: postgresql://user:pass@localhost:5432/naukrimili"
            exit 1
          fi
          
          # Additional validation: must contain :// after protocol
          if [[ ! "$DATABASE_URL" =~ :// ]]; then
            echo "‚ùå CRITICAL: DATABASE_URL missing '://' after protocol"
            echo "üìã Current format: ${DATABASE_URL:0:50}"
            echo ""
            echo "üìã How to fix:"
            echo "1. Go to GitHub Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Update DATABASE_URL secret"
            echo "3. Format: postgresql://username:password@host:port/database"
            exit 1
          fi
          
          # Validate URL structure more thoroughly
          if [[ ! "$DATABASE_URL" =~ ^postgres(ql)?://[^@]+@[^/]+/[^[:space:]]+ ]]; then
            echo "‚ùå CRITICAL: DATABASE_URL has invalid format"
            echo "üìã Current value (first 50 chars): ${DATABASE_URL:0:50}"
            echo ""
            echo "üìã Expected format: postgresql://username:password@host:port/database"
            echo "üìã Example: postgresql://user:pass@localhost:5432/naukrimili"
            echo ""
            echo "‚ö†Ô∏è  Please check GitHub Secrets ‚Üí DATABASE_URL"
            exit 1
          fi
          
          export DATABASE_URL
          echo "‚úÖ DATABASE_URL format is valid (protocol: $DB_PROTOCOL)"
          echo "üìã DATABASE_URL length: ${#DATABASE_URL} characters"
          
          # Generate Prisma client (with validation skip to prevent connection errors during build)
          echo "üóÑÔ∏è Generating Prisma client..."
          # Use --skip-engine-check to skip database connection validation during build
          # This is safe because we've already validated DATABASE_URL format above
          npx prisma generate --skip-engine-check || {
            echo "‚ö†Ô∏è Prisma generate with --skip-engine-check failed, trying without..."
            # If skip-engine-check fails, try with explicit DATABASE_URL
            DATABASE_URL="$DATABASE_URL" npx prisma generate || {
              echo "‚ùå Prisma generate failed"
              echo ""
              echo "üìã Troubleshooting:"
              echo "1. Verify DATABASE_URL in GitHub Secrets is correct"
              echo "2. Check that the database server is accessible"
              echo "3. Ensure the database user has proper permissions"
              echo "4. Format: postgresql://username:password@host:port/database"
              exit 1
            }
          }
          
          # Set NODE_ENV for production build (after dependencies are installed)
          export NODE_ENV=production
          export NEXT_TYPESCRIPT_IGNORE=1
          export ESLINT_NO_DEV_ERRORS=true
          # CRITICAL: Disable ESLint during production builds
          # Next.js 16+ disables ESLint by default, but we ensure it with env vars
          # ESLint is still available for developers via 'npm run lint' for code quality checks
          # Try with --no-lint flag first, fallback to regular build if flag not supported
          npx next build --no-lint || npx next build
          mkdir -p deploy && cp -r .next public prisma deploy/ && cp package.json package-lock.json ecosystem.config.cjs next.config.mjs server.cjs postcss.config.cjs tsconfig.json deploy/ 2>/dev/null || true
          cd deploy && tar -czf ../release.tar.gz . && cd .. && rm -rf deploy

      - uses: appleboy/scp-action@v0.1.5
        timeout-minutes: 5
        with:
          host: ${{ env.HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          port: ${{ env.SSH_PORT }}
          source: "release.tar.gz"
          target: "/var/www/naukrimili"
          timeout: 180s

      - uses: appleboy/ssh-action@v1.0.0
        timeout-minutes: 3
        env:
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          DATABASE_URL: ${{ env.DATABASE_URL }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
          GOOGLE_CLOUD_API_KEY: ${{ env.GOOGLE_CLOUD_API_KEY }}
          GOOGLE_CLIENT_ID: ${{ env.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ env.GOOGLE_CLIENT_SECRET }}
          GITHUB_ID: ${{ env.GITHUB_ID }}
          GITHUB_SECRET: ${{ env.GITHUB_SECRET }}
        with:
          host: ${{ env.HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          port: ${{ env.SSH_PORT }}
          timeout: 20s
          command_timeout: 3m
          envs: NEXTAUTH_SECRET,DATABASE_URL,OPENAI_API_KEY,GEMINI_API_KEY,GROQ_API_KEY,GOOGLE_CLOUD_OCR_API_KEY,GOOGLE_CLOUD_API_KEY,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,GITHUB_ID,GITHUB_SECRET
          script: |
            APP_DIR="/var/www/naukrimili"
            RELEASES_DIR="$APP_DIR/releases"
            CURRENT_LINK="$APP_DIR/current"
            BACKUP_LINK="$APP_DIR/previous"
            
            # Create releases directory if it doesn't exist
            mkdir -p "$RELEASES_DIR"
            
            # Generate unique release directory name
            RELEASE_NAME="release-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD 2>/dev/null || echo 'manual')"
            NEW_RELEASE="$RELEASES_DIR/$RELEASE_NAME"
            
            echo "üöÄ Starting zero-downtime deployment..."
            echo "üì¶ Release: $RELEASE_NAME"
            
            # Extract new release to versioned folder (NOT the live folder)
            echo "üìÇ Extracting new release..."
            mkdir -p "$NEW_RELEASE"
            cd "$NEW_RELEASE" || exit 1
            tar -xzf "$APP_DIR/release.tar.gz" || exit 1
            rm -f "$APP_DIR/release.tar.gz"
            
            # Install dependencies in new release folder
            echo "üì¶ Installing dependencies in new release..."
            npm ci --production --legacy-peer-deps --prefer-offline --no-audit || exit 1
            
            # Copy .env from current if it exists, otherwise create new
            if [ -f "$CURRENT_LINK/.env" ]; then
              echo "üìã Copying .env from current release..."
              cp "$CURRENT_LINK/.env" .env
            else
              echo "üìã Creating new .env file..."
              touch .env
            fi
            
            # Update OAuth secrets in .env
            sed -i '/^GOOGLE_CLIENT_ID=/d; /^GOOGLE_CLIENT_SECRET=/d; /^GITHUB_ID=/d; /^GITHUB_SECRET=/d' .env 2>/dev/null || true
            echo "GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID" >> .env
            echo "GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET" >> .env
            echo "GITHUB_ID=$GITHUB_ID" >> .env
            echo "GITHUB_SECRET=$GITHUB_SECRET" >> .env
            
            # Generate Prisma client and run migrations in new release
            echo "üóÑÔ∏è Setting up database..."
            if [ -d "prisma" ]; then
              npx prisma generate || true
              timeout 10 npx prisma migrate deploy || true
            fi
            
            # Create logs directory
            mkdir -p logs
            
            # Verify new release is ready
            echo "‚úÖ New release prepared: $NEW_RELEASE"
            
            # Backup current symlink if it exists (for rollback)
            if [ -L "$CURRENT_LINK" ]; then
              echo "üíæ Backing up current release..."
              CURRENT_RELEASE=$(readlink -f "$CURRENT_LINK")
              if [ -n "$CURRENT_RELEASE" ] && [ "$CURRENT_RELEASE" != "$NEW_RELEASE" ]; then
                ln -sfn "$CURRENT_RELEASE" "$BACKUP_LINK" 2>/dev/null || true
              fi
            elif [ -d "$CURRENT_LINK" ] && [ ! -L "$CURRENT_LINK" ]; then
              # First-time migration: move existing directory to releases
              echo "üîÑ Migrating existing installation to releases structure..."
              EXISTING_RELEASE="$RELEASES_DIR/release-$(date +%Y%m%d-%H%M%S)-existing"
              mv "$CURRENT_LINK" "$EXISTING_RELEASE" 2>/dev/null || true
              ln -sfn "$EXISTING_RELEASE" "$CURRENT_LINK" 2>/dev/null || true
              ln -sfn "$EXISTING_RELEASE" "$BACKUP_LINK" 2>/dev/null || true
            fi
            
            # Atomic symlink switch (this is the zero-downtime moment)
            echo "üîÑ Switching to new release (atomic operation)..."
            ln -sfn "$NEW_RELEASE" "$CURRENT_LINK.tmp"
            mv -f "$CURRENT_LINK.tmp" "$CURRENT_LINK"
            
            # Reload PM2 with new code (PM2 will gracefully reload)
            echo "üîÑ Reloading application..."
            cd "$CURRENT_LINK"
            # Update ecosystem config to use absolute path for cwd
            if pm2 list | grep -q "naukrimili"; then
              pm2 reload naukrimili --update-env || pm2 restart naukrimili --update-env || true
            else
              pm2 start ecosystem.config.cjs --env production --update-env || true
            fi
            
            # Wait for app to be ready
            echo "‚è≥ Waiting for application to start..."
            sleep 5
            
            # Health check
            echo "üè• Performing health check..."
            HEALTH_CHECK_PASSED=false
            for i in {1..10}; do
              if curl -f http://localhost:3000/api/health >/dev/null 2>&1 || curl -f http://localhost:3000/ >/dev/null 2>&1; then
                HEALTH_CHECK_PASSED=true
              fi
              # Also check PM2 status
              if pm2 describe naukrimili 2>/dev/null | grep -q "online\|status.*online"; then
                HEALTH_CHECK_PASSED=true
              fi
              if [ "$HEALTH_CHECK_PASSED" = "true" ]; then
                echo "‚úÖ Application is healthy!"
                pm2 save
                
                # Cleanup old releases (keep last 5)
                echo "üßπ Cleaning up old releases..."
                ls -dt "$RELEASES_DIR"/release-* 2>/dev/null | tail -n +6 | xargs rm -rf 2>/dev/null || true
                
                echo "üéâ Zero-downtime deployment completed successfully!"
                exit 0
              fi
              echo "‚è≥ Waiting for health check... ($i/10)"
              sleep 2
            done
            
            # Health check failed - rollback
            echo "‚ùå Health check failed! Rolling back..."
            if [ -L "$BACKUP_LINK" ]; then
              ROLLBACK_RELEASE=$(readlink -f "$BACKUP_LINK")
              echo "‚Ü©Ô∏è Rolling back to: $ROLLBACK_RELEASE"
              ln -sfn "$ROLLBACK_RELEASE" "$CURRENT_LINK"
              cd "$CURRENT_LINK"
              pm2 reload naukrimili --update-env || pm2 start ecosystem.config.cjs --env production --update-env
              sleep 3
              echo "‚úÖ Rollback completed - old version is running"
              pm2 save
              exit 1
            else
              echo "‚ö†Ô∏è No backup available - keeping new release but it may not be working"
              pm2 save
              exit 1
            fi
