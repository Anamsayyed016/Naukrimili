name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    # PostgreSQL service for Prisma during build (uses ephemeral test DB)
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    env:
      HOST: ${{ secrets.HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      NPM_REGISTRY: https://registry.npmjs.org/
      # API Keys for build and runtime
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
      GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
      GOOGLE_CLOUD_API_KEY: ${{ secrets.GOOGLE_CLOUD_API_KEY }}
      # For CI Prisma generate step only (uses local postgres service)
      PRISMA_DATABASE_URL: "postgresql://postgres:postgres@localhost:5432/testdb"
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Cache npm
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: npm-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            npm-${{ runner.os }}-

      - name: Cache prisma engines
        uses: actions/cache@v4
        with:
          path: ~/.cache/prisma
          key: prisma-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            prisma-${{ runner.os }}-

      - name: Configure npm (parallel optimizations)
        run: |
          npm config set registry "$NPM_REGISTRY"
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set maxsockets 100
          npm config set fetch-retries 2
          npm config set fetch-retry-mintimeout 2000
          npm config set fetch-retry-maxtimeout 60000

      - name: Install dependencies (faster CI)
        run: |
          npm ci --legacy-peer-deps --prefer-offline --no-audit --cache ~/.npm --fetch-timeout=60000 --fetch-retries=2 2>&1 | grep -E "^(added|up to date)" || true

      - name: Build (production optimized)
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: https://naukrimili.com
          NEXT_PUBLIC_APP_URL: https://naukrimili.com
          DATABASE_URL: ${{ env.PRISMA_DATABASE_URL }}
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          NODE_OPTIONS: --max-old-space-size=4096
          SWC_NUM_THREADS: 4
          # API Keys available during build
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
          GOOGLE_CLOUD_API_KEY: ${{ env.GOOGLE_CLOUD_API_KEY }}
        run: |
           # Wait for Postgres to be ready
           until pg_isready -h localhost -p 5432 -U postgres; do echo "Waiting for Postgres..."; sleep 1; done
         
           # Initialize database schema in CI (creates tables in testdb so build queries work)
           echo "üóÑÔ∏è Initializing CI database schema..."
           
           # CRITICAL: Use db push FIRST to sync schema and create all tables
           # This ensures all tables exist before migrations try to reference them
           echo "üìã Syncing database schema (creates all tables from schema.prisma)..."
           npx prisma db push --schema=./prisma/schema.prisma --skip-generate --accept-data-loss || {
             echo "‚ö†Ô∏è  db push had warnings, but continuing..."
           }
           
           # Then run migrations to apply any pending migration changes
           echo "üîÑ Running pending migrations..."
           npx prisma migrate deploy --schema=./prisma/schema.prisma || {
             echo "‚ö†Ô∏è  Some migrations may have failed. Checking if it's just idempotent warnings..."
             # Migrations are now idempotent, so warnings are acceptable
           }
         
           # Generate Prisma client
           npx prisma generate --skip-engine-check 2>/dev/null || npx prisma generate
         
           # Build application
           npm run build

      - name: Optimize for production
        run: |
          # Keep only production node_modules (removes dev deps)
          npm prune --production --no-save
          # Remove unnecessary files from node_modules
          find node_modules -type d -name ".bin" -prune -o -type f \( -name "*.md" -o -name "*.ts" -o -name "*.map" \) -delete 2>/dev/null || true
          # Remove build cache
          rm -rf .next/cache .next/static/chunks/*.map 2>/dev/null || true

      - name: Create minimal deployment bundle
        run: |
          mkdir -p deploy && cd deploy
          cp -r ../.next .
          cp -r ../node_modules .
          cp ../package.json ../package-lock.json ../ecosystem.config.cjs ../next.config.mjs ../server.cjs .
          cp -r ../public ../prisma .
          # Include database initialization script (create scripts directory and copy script)
          mkdir -p scripts
          if [ -f ../scripts/init-database.sh ]; then
            cp ../scripts/init-database.sh scripts/
          fi
          cp ../.env.production . 2>/dev/null || true
          cd ..
          # Use zstd level 3 for fast compression/decompression (level 19 is too slow)
          tar -I 'zstd -3 --threads=0' -cf release.tar.zst deploy/
          rm -rf deploy
          ls -lh release.tar.zst

      - name: Upload artifact to server (zstd compression)
        uses: appleboy/scp-action@v0.1.5
        with:
          host: ${{ env.HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          port: ${{ env.SSH_PORT }}
          source: "release.tar.zst"
          target: "/var/www/naukrimili"

      - name: Deploy via SSH (optimized)
        uses: appleboy/ssh-action@v1.0.0
        env:
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          DATABASE_URL: ${{ env.DATABASE_URL }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
          GOOGLE_CLOUD_API_KEY: ${{ env.GOOGLE_CLOUD_API_KEY }}
        with:
          host: ${{ env.HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          port: ${{ env.SSH_PORT }}
          timeout: 60s
          command_timeout: 15m
          envs: NEXTAUTH_SECRET,DATABASE_URL,OPENAI_API_KEY,GEMINI_API_KEY,GROQ_API_KEY,GOOGLE_CLOUD_OCR_API_KEY,GOOGLE_CLOUD_API_KEY
          script: |
            set -e
            cd /var/www/naukrimili
            
            echo "‚ö° Starting optimized deployment..."
            
            # Ensure zstd is installed on server
            if ! command -v zstd &> /dev/null; then
              echo "üì¶ Installing zstd on server..."
              if command -v apt-get &> /dev/null; then
                sudo apt-get update -qq && sudo apt-get install -y zstd
              elif command -v yum &> /dev/null; then
                sudo yum install -y zstd
              elif command -v apk &> /dev/null; then
                sudo apk add zstd
              else
                echo "‚ö†Ô∏è  Could not install zstd automatically. Please install it manually."
              fi
            fi
            
            # Extract deployment bundle
            echo "üì¶ Extracting deployment bundle..."
            if command -v zstd &> /dev/null; then
              tar -I 'zstd -d --threads=0' -xf release.tar.zst 2>&1 | grep -E "(deploy/|extracting)" | head -20 || \
              { echo "‚ö†Ô∏è Extraction taking longer than expected, continuing..."; tar -I 'zstd -d --threads=0' -xf release.tar.zst; }
            else
              echo "‚ùå zstd not found. Cannot extract bundle."
              exit 1
            fi
            
            # Move to production location
            echo "üöÄ Installing new version..."
            rm -rf .next node_modules
            mv deploy/.next deploy/node_modules deploy/package.json deploy/ecosystem.config.cjs \
               deploy/next.config.mjs deploy/server.cjs deploy/prisma deploy/public . 2>/dev/null || true
            # Copy scripts directory if it exists
            if [ -d "deploy/scripts" ]; then
              mkdir -p scripts
              cp -r deploy/scripts/* scripts/ 2>/dev/null || true
            fi
            
            # Cleanup
            rm -rf deploy release.tar.zst .next.backup
            
            # Set environment
            export NODE_ENV=production
            export NEXTAUTH_SECRET="$NEXTAUTH_SECRET"
            export NEXTAUTH_URL="https://naukrimili.com"
            export NEXT_PUBLIC_APP_URL="https://naukrimili.com"
            export DATABASE_URL="$DATABASE_URL"
            export NEXT_TELEMETRY_DISABLED=1
            # API Keys for runtime
            export OPENAI_API_KEY="$OPENAI_API_KEY"
            export GEMINI_API_KEY="$GEMINI_API_KEY"
            export GROQ_API_KEY="$GROQ_API_KEY"
            export GOOGLE_CLOUD_OCR_API_KEY="$GOOGLE_CLOUD_OCR_API_KEY"
            export GOOGLE_CLOUD_API_KEY="$GOOGLE_CLOUD_API_KEY"
            
            # Initialize database (create user and database if needed)
            echo "üóÑÔ∏è Initializing database..."
            if [ -f "scripts/init-database.sh" ]; then
              chmod +x scripts/init-database.sh
              bash scripts/init-database.sh || {
                echo "‚ö†Ô∏è  Database initialization script failed, continuing with migrations..."
              }
            else
              echo "‚ö†Ô∏è  Database initialization script not found, skipping user/database creation"
            fi
            
            # Run database migrations (critical - creates tables)
            echo "üîÑ Running database migrations..."
            if [ -d "prisma" ]; then
              # Generate Prisma client first
              npx prisma generate --schema=./prisma/schema.prisma || {
                echo "‚ö†Ô∏è  Prisma generate failed, but continuing..."
              }
              
              # First, ensure schema is synced (creates all tables from schema.prisma)
              echo "üìã Syncing database schema to ensure all tables exist..."
              npx prisma db push --schema=./prisma/schema.prisma --skip-generate --accept-data-loss 2>&1 | tee /tmp/dbpush.log || {
                echo "‚ö†Ô∏è  db push failed, but continuing with migrations..."
                cat /tmp/dbpush.log | tail -10
              }
              
              # Then run migrations to apply any pending migration changes
              echo "üîÑ Running pending migrations..."
              npx prisma migrate deploy --schema=./prisma/schema.prisma 2>&1 | tee /tmp/migration.log || {
                echo "‚ö†Ô∏è  Some migrations may have failed. Checking logs..."
                cat /tmp/migration.log | tail -20
                echo ""
                echo "‚ö†Ô∏è  Migration warnings are acceptable if tables/columns already exist"
              }
              echo "‚úÖ Database migrations complete"
            else
              echo "‚ö†Ô∏è No prisma directory found, skipping migrations"
            fi
            
            # Stop and start PM2 (parallel, no sleep)
            echo "üîÑ Restarting PM2 process..."
            pm2 delete jobportal 2>/dev/null || true
            mkdir -p ./logs
            pm2 start ecosystem.config.cjs --env production --update-env --no-wait
            
            # Quick health check (5 attempts, 1 second each)
            echo "üè• Health check..."
            for i in {1..5}; do
              if curl -sf --max-time 2 http://localhost:3000/api/health > /dev/null 2>&1; then
                echo "‚úÖ App is healthy"
                pm2 save
                echo "‚úÖ Deployment complete in ~$(echo $SECONDS)s"
                exit 0
              fi
              [ $i -lt 5 ] && sleep 1
            done
            
            echo "‚ö†Ô∏è Health check timed out (app may still be starting)"
            exit 0
