name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    env:
      HOST: ${{ secrets.HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
      GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
      NPM_REGISTRY: https://registry.npmjs.org/
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify deployment secrets
        run: |
          echo "🔍 Verifying deployment configuration..."
          MISSING_SECRETS=()
          
          [ -z "${{ secrets.HOST }}" ] && MISSING_SECRETS+=("HOST")
          [ -z "${{ secrets.SSH_USER }}" ] && MISSING_SECRETS+=("SSH_USER")
          [ -z "${{ secrets.SSH_KEY }}" ] && MISSING_SECRETS+=("SSH_KEY")
          [ -z "${{ secrets.SSH_PORT }}" ] && MISSING_SECRETS+=("SSH_PORT")
          [ -z "${{ secrets.NEXTAUTH_SECRET }}" ] && MISSING_SECRETS+=("NEXTAUTH_SECRET")
          [ -z "${{ secrets.DATABASE_URL }}" ] && MISSING_SECRETS+=("DATABASE_URL")
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "❌ Missing required secrets: ${MISSING_SECRETS[*]}"
            echo "Please configure these in GitHub repository Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          echo "✅ All required secrets are configured"
          echo ""
          echo "📊 Secret Configuration Summary:"
          echo "  - HOST: ${{ secrets.HOST }}"
          echo "  - SSH_USER: ${{ secrets.SSH_USER }}"
          echo "  - SSH_PORT: ${{ secrets.SSH_PORT }}"
          echo "  - SSH_KEY format: $(echo '${{ secrets.SSH_KEY }}' | head -c 30)..."
          echo "  - SSH_KEY lines: $(echo '${{ secrets.SSH_KEY }}' | wc -l)"
          echo "  - SSH_KEY size: $(echo -n '${{ secrets.SSH_KEY }}' | wc -c) bytes"
          echo ""
          echo "🔑 SSH Key validation:"
          
          # Write key to temp file for validation
          echo "${{ secrets.SSH_KEY }}" > /tmp/ssh_key_test
          chmod 600 /tmp/ssh_key_test
          
          # Check key format
          if grep -q "BEGIN.*PRIVATE KEY" /tmp/ssh_key_test; then
            echo "  ✅ SSH key has valid header"
            KEY_TYPE=$(head -1 /tmp/ssh_key_test | sed 's/.*BEGIN \(.*\) PRIVATE.*/\1/')
            echo "  ✅ Key type: $KEY_TYPE"
          else
            echo "  ❌ SSH key format is INVALID - does not contain 'BEGIN ... PRIVATE KEY'"
            echo "  First line: $(head -1 /tmp/ssh_key_test)"
            echo "  Expected format: '-----BEGIN OPENSSH PRIVATE KEY-----' or similar"
            exit 1
          fi
          
          # Check key has END marker
          if grep -q "END.*PRIVATE KEY" /tmp/ssh_key_test; then
            echo "  ✅ SSH key has valid footer"
          else
            echo "  ❌ SSH key missing END marker"
            exit 1
          fi
          
          rm /tmp/ssh_key_test
          echo "✅ SSH key validation passed"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Configure npm (parallel optimizations)
        run: |
          npm config set registry "$NPM_REGISTRY"
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set maxsockets 128
          npm config set fetch-retries 1
          npm config set fetch-retry-mintimeout 1000

      - name: Install dependencies (build only)
        run: |
          npm ci --legacy-peer-deps --no-audit --prefer-offline 2>&1 | tail -3

      - name: Clean old Prisma generated client
        run: |
          echo "🧹 Removing any stale Prisma generated client output..."
          rm -rf lib/generated/prisma || true
          ls -lah lib || true

      - name: Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
        run: |
          echo "🔧 Generating Prisma Client..."
          # Capture full prisma generate output for debugging
          npx prisma generate --schema=prisma/schema.prisma 2>&1 | tee prisma-generate.log
          GEN_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}

          if [ $GEN_EXIT -ne 0 ]; then
            echo "❌ Prisma generation failed with exit code $GEN_EXIT"
            echo "===== Last 200 lines of prisma-generate.log ====="
            tail -n 200 prisma-generate.log || true
            echo "===== End prisma generate log ====="
            exit $GEN_EXIT
          fi

          # Check common locations for generated client
          if [ ! -d lib/generated/prisma/client ] && [ ! -d node_modules/.prisma/client ] && [ ! -d node_modules/@prisma/client ]; then
            echo "⚠️ Warning: Prisma client not found in expected locations. Listing directories for debugging:"
            ls -lah lib/generated/prisma || true
            ls -lah node_modules/.prisma || true
            ls -lah node_modules/@prisma || true
          else
            echo "✅ Prisma client generated successfully"
          fi

      - name: Build (production optimized)
        timeout-minutes: 8
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: https://naukrimili.com
          NEXT_PUBLIC_APP_URL: https://naukrimili.com
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          SKIP_BUILD_DB_QUERIES: true
          # Provide a syntactically valid fake DATABASE_URL so Prisma env("DATABASE_URL") resolves during build
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NODE_OPTIONS: --max-old-space-size=4096
          SWC_NUM_THREADS: 4
          ESLINT_NO_DEV_ERRORS: true
          GOOGLE_CLIENT_ID: ${{ env.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ env.GOOGLE_CLIENT_SECRET }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
        run: |
          echo "🔨 Starting production build..."
          echo "📍 Current directory: $(pwd)"
          echo "🔧 Node version: $(node --version)"
          echo "📦 npm version: $(npm --version)"
          
          # Configure npm for reliable builds
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set fetch-retries 3
          npm config set loglevel verbose
          
          # Run build and capture full output to build-output.log for CI artifacts
          # Explicitly pass all env vars to ensure they're available during build
          NEXTAUTH_SECRET="${NEXTAUTH_SECRET}" \
          NEXTAUTH_URL="https://naukrimili.com" \
          NEXT_PUBLIC_APP_URL="https://naukrimili.com" \
          GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID}" \
          GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET}" \
          OPENAI_API_KEY="${OPENAI_API_KEY}" \
          GEMINI_API_KEY="${GEMINI_API_KEY}" \
          GROQ_API_KEY="${GROQ_API_KEY}" \
          GOOGLE_CLOUD_OCR_API_KEY="${GOOGLE_CLOUD_OCR_API_KEY}" \
          NODE_ENV=production \
          NODE_OPTIONS="--max-old-space-size=4096" \
          NEXT_TELEMETRY_DISABLED=1 \
          SKIP_ENV_VALIDATION=1 \
          SKIP_DB_VALIDATION=true \
          SKIP_BUILD_DB_QUERIES=true \
          DATABASE_URL="postgresql://ci:ci@127.0.0.1:5432/ci" \
          npm run build:linux 2>&1 | tee build-output.log || true
          BUILD_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}

          # Fallback to standard Next.js build if custom script failed
          if [ $BUILD_EXIT -ne 0 ]; then
            echo "⚠️ build:linux failed with exit code $BUILD_EXIT, attempting fallback 'npm run build'"
            NEXTAUTH_SECRET="${NEXTAUTH_SECRET}" \
            NEXTAUTH_URL="https://naukrimili.com" \
            NEXT_PUBLIC_APP_URL="https://naukrimili.com" \
            GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID}" \
            GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET}" \
            OPENAI_API_KEY="${OPENAI_API_KEY}" \
            GEMINI_API_KEY="${GEMINI_API_KEY}" \
            GROQ_API_KEY="${GROQ_API_KEY}" \
            GOOGLE_CLOUD_OCR_API_KEY="${GOOGLE_CLOUD_OCR_API_KEY}" \
            NODE_ENV=production \
            NODE_OPTIONS="--max-old-space-size=4096" \
            NEXT_TELEMETRY_DISABLED=1 \
            SKIP_ENV_VALIDATION=1 \
            SKIP_DB_VALIDATION=true \
            SKIP_BUILD_DB_QUERIES=true \
            DATABASE_URL="postgresql://ci:ci@127.0.0.1:5432/ci" \
            npm run build 2>&1 | tee -a build-output.log || true
            FALLBACK_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}
            if [ $FALLBACK_EXIT -ne 0 ]; then
              echo "⚠️ fallback 'npm run build' failed, attempting 'npx next build'"
              npx next build 2>&1 | tee -a build-output.log || true
              BUILD_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}
            else
              BUILD_EXIT=$FALLBACK_EXIT
            fi
          fi
          
          if [ $BUILD_EXIT -ne 0 ]; then
            echo ""
            echo "❌ Build failed with exit code $BUILD_EXIT"
            echo ""
            echo "===== Last 200 lines of build-output.log ====="
            tail -n 200 build-output.log || true
            echo "===== End build log snippet ====="
            echo ""
            echo "📁 Directory contents after failed build:"
            ls -lah | head -30
            exit $BUILD_EXIT
          fi
          
          # Verify build output
          if [ ! -d .next ]; then
            echo "❌ CRITICAL: Build failed - .next directory not created"
            echo "📁 Current directory contents:"
            ls -lah
            echo ""
            echo "🔍 Total disk usage:"
            du -sh . | head -5
            exit 1
          fi
          
          NEXT_SIZE=$(du -sh .next | cut -f1)
          echo "✅ Build completed successfully"
          echo "📊 Build output size: $NEXT_SIZE"
          
          # Extra verification - count files in .next
          FILE_COUNT=$(find .next -type f | wc -l)
          echo "📈 Number of files in .next: $FILE_COUNT"
          
          if [ "$FILE_COUNT" -lt 100 ]; then
            echo "⚠️  WARNING: Unusually low file count in .next directory"
          fi

      - name: Upload build logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: |
            build-output.log

      - name: Prepare deployment bundle
        run: |
          echo "🔍 Checking build artifacts..."
          
          if [ ! -d .next ]; then
            echo "❌ CRITICAL: .next directory not found!"
            echo "📁 Current directory contents:"
            ls -lah | head -20
            exit 1
          fi
          
          echo "✅ .next directory found ($(du -sh .next | cut -f1))"
          
          DEPLOY_DIR="/tmp/naukrimili_deploy_$$"
          mkdir -p "$DEPLOY_DIR"
          
          # Copy only essential files
          echo "📋 Copying build artifacts..."
          cp -r .next "$DEPLOY_DIR/"
          find "$DEPLOY_DIR/.next" -name '*.map' -delete 2>/dev/null || true
          find "$DEPLOY_DIR/.next/cache" -type f -delete 2>/dev/null || true
          
          for file in package.json package-lock.json ecosystem.config.cjs next.config.mjs server.cjs; do
            if [ -f "$file" ]; then
              cp "$file" "$DEPLOY_DIR/"
              echo "  ✓ $file"
            fi
          done
          
          [ -d public ] && cp -r public "$DEPLOY_DIR/" && echo "  ✓ public/"
          [ -d prisma ] && cp -r prisma "$DEPLOY_DIR/" && echo "  ✓ prisma/"
          
          # Create tar.zst
          echo "📦 Creating deployment bundle..."
          cd "$DEPLOY_DIR"
          tar -I 'zstd -1 -T0' -cf ../release.tar.zst . || { echo "❌ tar failed"; exit 1; }
          cd - > /dev/null
          
          mv "$DEPLOY_DIR/release.tar.zst" release.tar.zst 2>/dev/null || mv "$DEPLOY_DIR/../release.tar.zst" release.tar.zst
          
          if [ ! -f release.tar.zst ]; then
            echo "❌ release.tar.zst not created"
            exit 1
          fi
          
          BUNDLE_SIZE=$(ls -lh release.tar.zst | awk '{print $5}')
          echo "✅ Bundle created: $BUNDLE_SIZE"
          
          # Verify bundle integrity
          if tar -I 'zstd -d -T0' -tf release.tar.zst | head -5 >/dev/null 2>&1; then
            echo "✅ Bundle integrity verified"
          else
            echo "❌ Bundle integrity check failed"
            exit 1
          fi
          
          rm -rf "$DEPLOY_DIR"

      - name: Test server connectivity
        env:
          TEST_HOST: ${{ secrets.HOST }}
          TEST_PORT: ${{ secrets.SSH_PORT }}
        run: |
          echo "🌐 Testing connectivity to server..."
          
          HOST="$TEST_HOST"
          SSH_PORT="$TEST_PORT"
          
          # Validate secrets are not empty
          if [ -z "$HOST" ]; then
            echo "❌ ERROR: HOST secret is empty or not set"
            echo "   Please configure HOST in GitHub Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          if [ -z "$SSH_PORT" ]; then
            echo "❌ ERROR: SSH_PORT secret is empty or not set"
            echo "   Please configure SSH_PORT in GitHub Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          echo "Target: $HOST:$SSH_PORT"
          echo ""
          
          # Try netcat if available
          echo "Testing with netcat..."
          if command -v nc &> /dev/null; then
            if nc -zv -w 3 "$HOST" "$SSH_PORT" 2>&1; then
              echo "✅ Netcat: Connection successful on port $SSH_PORT"
            else
              NETCAT_RESULT=$?
              echo "⚠️ Netcat: Connection failed (exit code $NETCAT_RESULT)"
            fi
          else
            echo "⚠️ netcat not available"
          fi
          
          echo ""
          echo "Testing with bash TCP socket..."
          
          # Test using bash TCP socket (timeout = 5 seconds)
          (sleep 5; exec 3<>/dev/tcp/"$HOST"/"$SSH_PORT") 2>/dev/null && {
            exec 3>&-
            echo "✅ Bash TCP: Connection successful on port $SSH_PORT"
          } || {
            TCP_RESULT=$?
            echo "❌ Bash TCP: Connection FAILED on port $SSH_PORT"
            echo "   Error code: $TCP_RESULT"
            echo ""
            echo "⚠️ IMPORTANT: This means the server is NOT REACHABLE at $HOST:$SSH_PORT"
            echo ""
            echo "🔍 Configuration verification:"
            echo "   - HOST: $HOST"
            echo "   - SSH_PORT: $SSH_PORT"
            echo ""
            echo "🔍 Possible causes:"
            echo "   1. HOST secret is incorrect (check GitHub Secrets)"
            echo "   2. SSH_PORT secret is incorrect or missing"
            echo "   3. Server is not running or not accepting SSH connections"
            echo "   4. Firewall/Security Groups blocking inbound traffic on port $SSH_PORT"
            echo "   5. GitHub Actions IP is blocked by server firewall"
            echo ""
            echo "💡 Debug commands to run on YOUR LOCAL machine:"
            echo "   ssh -v -p $SSH_PORT your-user@$HOST"
            echo "   Or: nc -zv $HOST $SSH_PORT"
            echo "   Or: telnet $HOST $SSH_PORT"
            echo ""
            echo "🆘 If local SSH works but GitHub Actions fails:"
            echo "   - GitHub Actions runners may be blocked by your server's firewall"
            echo "   - Contact your hosting provider to whitelist GitHub's IP ranges"
            echo ""
            exit 1
          }

      - name: Fast upload and deploy
        env:
          DEPLOY_HOST: ${{ secrets.HOST }}
          DEPLOY_SSH_USER: ${{ secrets.SSH_USER }}
          DEPLOY_SSH_KEY: ${{ secrets.SSH_KEY }}
          DEPLOY_SSH_PORT: ${{ secrets.SSH_PORT }}
        run: |
          set -e
          
          echo "🔍 Pre-flight checks..."
          
          # Validate required secrets are not empty
          if [ -z "$DEPLOY_HOST" ]; then
            echo "❌ ERROR: HOST secret is not set"
            exit 1
          fi
          if [ -z "$DEPLOY_SSH_USER" ]; then
            echo "❌ ERROR: SSH_USER secret is not set"
            exit 1
          fi
          if [ -z "$DEPLOY_SSH_PORT" ]; then
            echo "❌ ERROR: SSH_PORT secret is not set"
            exit 1
          fi
          if [ -z "$DEPLOY_SSH_KEY" ]; then
            echo "❌ ERROR: SSH_KEY secret is not set"
            exit 1
          fi
          
          # Check bundle exists
          if [ ! -f release.tar.zst ]; then
            echo "❌ ERROR: release.tar.zst not found in current directory"
            echo "📁 Current directory:"
            ls -lah | grep -E "tar.zst|release|\.next"
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.zst | cut -f1)
          echo "✅ Bundle found: $BUNDLE_SIZE"
          
          # Check required commands
          echo "🔧 Checking required tools..."
          for cmd in ssh rsync zstd tar; do
            if ! command -v $cmd >/dev/null 2>&1; then
              echo "❌ ERROR: $cmd not found"
              exit 1
            else
              echo "  ✓ $cmd available"
            fi
          done
          
          echo "✅ All secrets present"
          
          # Setup SSH
          echo "🔑 Setting up SSH..."
          mkdir -p ~/.ssh
          
          # Expand escaped newlines in the SSH key (handle \n escape sequences)
          printf '%b' "$DEPLOY_SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key format
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "⚠️  WARNING: SSH key format may be incorrect"
            echo "First 50 chars: $(head -c 50 ~/.ssh/deploy_key)"
            echo ""
            echo "🔍 Debugging key content:"
            wc -l ~/.ssh/deploy_key
            head -1 ~/.ssh/deploy_key
            exit 1
          fi
          
          echo "✅ SSH key validated"
          
          echo "🌐 Scanning SSH host keys..."
          ssh-keyscan -p "$DEPLOY_SSH_PORT" -T 5 "$DEPLOY_HOST" >> ~/.ssh/known_hosts 2>/dev/null || {
            echo "⚠️  ssh-keyscan failed, trying with verbose output..."
            ssh-keyscan -v -p "$DEPLOY_SSH_PORT" -T 5 "$DEPLOY_HOST" 2>&1 | head -20
          }
          
          echo "🧪 Testing SSH connection with keepalive options..."
          SSH_TEST=$(ssh -i ~/.ssh/deploy_key \
            -p "$DEPLOY_SSH_PORT" \
            -o StrictHostKeyChecking=accept-new \
            -o ConnectTimeout=15 \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=5 \
            -o BatchMode=yes \
            -vv \
            "$DEPLOY_SSH_USER@$DEPLOY_HOST" "whoami && pwd" 2>&1) || {
            echo "❌ SSH connection test failed"
            echo ""
            echo "📋 SSH Test Output:"
            echo "$SSH_TEST" | tail -50
            exit 1
          }
          
          echo "✅ SSH connection successful"
          REMOTE_USER=$(echo "$SSH_TEST" | grep -v debug | tail -1 | head -c 50)
          echo "Remote info: $REMOTE_USER"
          
          echo "📤 Starting rsync upload..."
          echo "Source: release.tar.zst ($BUNDLE_SIZE)"
          echo "Target: $DEPLOY_SSH_USER@$DEPLOY_HOST:/var/www/naukrimili/"
          
          # Define SSH options with keepalive to prevent "Broken pipe"
          SSH_OPTS="-i ~/.ssh/deploy_key -p $DEPLOY_SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 -o BatchMode=yes"
          
          if rsync -avz --progress --partial --delay-updates \
            -e "ssh $SSH_OPTS" \
            release.tar.zst "$DEPLOY_SSH_USER@$DEPLOY_HOST:/var/www/naukrimili/" 2>&1 | tee rsync.log; then
            echo "✅ Upload complete"
          else
            RSYNC_EXIT=$?
            echo ""
            echo "❌ rsync upload failed with exit code $RSYNC_EXIT"
            echo "Last 50 lines of rsync output:"
            tail -50 rsync.log || true
            echo ""
            echo "🔍 Debugging info:"
            echo "SSH command used: ssh $SSH_OPTS"
            echo "Target: $DEPLOY_SSH_USER@$DEPLOY_HOST:/var/www/naukrimili/"
            exit 1
          fi

      - name: Upload deployment logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: |
            rsync.log
            ssh-debug.log
          retention-days: 7

      - name: Deploy via SSH (ultra-fast)
        env:
          DEPLOY_HOST: ${{ secrets.HOST }}
          DEPLOY_SSH_USER: ${{ secrets.SSH_USER }}
          DEPLOY_SSH_PORT: ${{ secrets.SSH_PORT }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
        run: |
          # Create deployment script with env vars embedded
          cat > /tmp/deploy_script.sh <<'DEPLOY_SCRIPT'
          set -euo pipefail
          
          # Enable error handling
          trap 'echo "❌ Deployment failed at line $LINENO"; exit 1' ERR
          
          START_TIME=$(date +%s)
          DEPLOY_PATH="/var/www/naukrimili"
          
          # Verify deploy directory exists
          if [ ! -d "$DEPLOY_PATH" ]; then
            echo "❌ ERROR: Deploy directory $DEPLOY_PATH does not exist"
            ls -la /var/www/ 2>/dev/null || echo "❌ Cannot read /var/www/"
            exit 1
          fi
          
          cd "$DEPLOY_PATH"
          echo "⚡ Fast deployment started in $DEPLOY_PATH"
          
          # Check for bundle
          if [ ! -f "release.tar.zst" ]; then
            echo "❌ ERROR: release.tar.zst not found in $DEPLOY_PATH"
            echo "📁 Current directory contents:"
            ls -lah | head -20
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.zst | cut -f1)
          echo "📦 Found bundle: $BUNDLE_SIZE"
          
          # Install zstd if missing
          if ! command -v zstd >/dev/null 2>&1; then
            echo "⚠️  zstd not found, installing..."
            apt-get update -qq 2>/dev/null || true
            apt-get install -y zstd >/dev/null 2>&1 || {
              echo "⚠️  Failed to install zstd, attempting decompression anyway..."
            }
          fi
          
          # Extract
          echo "📦 Extracting bundle..."
          if ! tar -I 'zstd -d -T0' -xf release.tar.zst; then
            echo "❌ Failed to extract release.tar.zst"
            echo "Attempting to check bundle integrity..."
            tar -I 'zstd -d -T0' -tzf release.tar.zst 2>&1 | head -20 || true
            exit 1
          fi
          
          echo "✅ Bundle extracted"
          rm -f release.tar.zst
          
          # Verify extracted files
          if [ ! -d .next ]; then
            echo "❌ .next directory not found after extraction"
            ls -lah | grep -E "next|app" || echo "No .next/app files found"
            exit 1
          fi
          
          echo "✅ Build artifacts verified"
          
          # Ultra-fast dependency handling
          LOCKFILE_HASH=$(md5sum package-lock.json 2>/dev/null | cut -d' ' -f1)
          PREV_HASH=$(cat .lock_hash 2>/dev/null || echo "none")
          
          if [ -d node_modules ] && [ "$LOCKFILE_HASH" = "$PREV_HASH" ]; then
            echo "⏭️  Skipping npm install (unchanged)"
          else
            echo "📚 Installing production deps..."
            
            # Configure npm for maximum speed with verbose output for debugging
            npm config set cache /var/www/naukrimili/.npm-cache --global
            npm config set registry https://registry.npmjs.org/ --global
            npm config set prefer-offline true --global
            npm config set fund false --global
            npm config set audit false --global
            npm config set progress false --global
            npm config set fetch-retries 3 --global
            npm config set fetch-retry-mintimeout 1000 --global
            npm config set fetch-retry-maxtimeout 3000 --global
            npm config set maxsockets 50 --global
            npm config set loglevel warn --global
            
            # Skip puppeteer, tesseract, and other dev-only packages downloads
            export PUPPETEER_SKIP_DOWNLOAD=true
            export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
            export TESSERACT_SKIP_DOWNLOAD=true
            export npm_config_ignore_scripts=false
            export SKIP_POSTINSTALL=1
            
            # Check if we already have node_modules and it's valid
            INSTALL_LOG="/tmp/npm-install-$$.log"
            
            # Clean any partial/corrupted node_modules to prevent ENOTEMPTY errors
            echo "🧹 Checking for stale node_modules..."
            if [ -d node_modules ]; then
              # Check if lockfile changed (need fresh install)
              if [ "$LOCKFILE_HASH" != "$PREV_HASH" ]; then
                echo "⚠️  Lockfile changed, cleaning node_modules to prevent conflicts..."
                rm -rf node_modules
              else
                echo "✓ node_modules exists and lockfile unchanged"
              fi
            fi
            
            # Fast path: use ci if package-lock exists
            if [ -f package-lock.json ]; then
              echo "✓ Using npm ci (fast reproducible install)"
              echo "✓ Skipping Puppeteer/Chromium download"
              echo "✓ Skipping Tesseract download"
              
              # npm ci requires clean state - remove node_modules if exists
              if [ -d node_modules ]; then
                echo "🧹 Removing existing node_modules for clean npm ci..."
                rm -rf node_modules || {
                  echo "⚠️  Failed to remove node_modules, trying with sudo..."
                  sudo rm -rf node_modules || {
                    echo "❌ Cannot remove node_modules even with sudo"
                    exit 1
                  }
                }
              fi
              
              if timeout 180 npm ci --omit=dev --prefer-offline --ignore-scripts 2>&1 | tee "$INSTALL_LOG"; then
                echo "✅ npm ci succeeded"
                echo "$LOCKFILE_HASH" > .lock_hash
              else
                INSTALL_EXIT=$?
                echo ""
                echo "⚠️  npm ci failed with exit code $INSTALL_EXIT"
                echo "Last 50 lines of install log:"
                tail -50 "$INSTALL_LOG" || true
                
                # Try fallback install without ignore-scripts
                echo ""
                echo "Attempting fallback: clean npm install..."
                rm -rf node_modules package-lock.json
                
                # Fix permissions before retry
                echo "🔧 Fixing file permissions..."
                sudo chown -R $(whoami):$(whoami) . 2>/dev/null || true
                
                if timeout 180 npm install --omit=dev --prefer-offline 2>&1 | tee "$INSTALL_LOG"; then
                  echo "✅ npm install fallback succeeded"
                  echo "$LOCKFILE_HASH" > .lock_hash
                else
                  echo ""
                  echo "❌ Both npm ci and npm install failed"
                  echo "Last 100 lines of install log:"
                  tail -100 "$INSTALL_LOG" || true
                  echo ""
                  echo "🔍 Checking node_modules for partial install:"
                  du -sh node_modules 2>/dev/null || echo "node_modules: not found"
                  echo ""
                  echo "🔍 Checking if it's a network issue:"
                  npm config get registry
                  echo ""
                  echo "🔍 Checking file permissions:"
                  ls -la . | head -10
                  rm -f "$INSTALL_LOG"
                  exit 1
                fi
              fi
            else
              echo "Using npm install (no lock file)..."
              if timeout 180 npm install --omit=dev --ignore-scripts 2>&1 | tee "$INSTALL_LOG"; then
                echo "✅ npm install succeeded"
                echo "$LOCKFILE_HASH" > .lock_hash
              else
                echo "❌ npm install failed"
                echo "Last 100 lines of install log:"
                tail -100 "$INSTALL_LOG" || true
                rm -f "$INSTALL_LOG"
                exit 1
              fi
            fi
            rm -f "$INSTALL_LOG"
          fi
          
          # Set env vars
          export NODE_ENV=production \
                 NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
                 NEXTAUTH_URL=https://naukrimili.com \
                 NEXT_PUBLIC_APP_URL=https://naukrimili.com \
                 DATABASE_URL="$DATABASE_URL" \
                 NEXT_TELEMETRY_DISABLED=1 \
                 GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
                 GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET" \
                 OPENAI_API_KEY="$OPENAI_API_KEY" \
                 GEMINI_API_KEY="$GEMINI_API_KEY" \
                 GROQ_API_KEY="$GROQ_API_KEY" \
                 GOOGLE_CLOUD_OCR_API_KEY="$GOOGLE_CLOUD_OCR_API_KEY"
          
          # Migrations (skip if unchanged)
          if [ -f prisma/schema.prisma ]; then
            SCHEMA_HASH=$(md5sum prisma/schema.prisma 2>/dev/null | cut -d' ' -f1)
            if [ "$SCHEMA_HASH" != "$(cat .prisma_hash 2>/dev/null)" ]; then
              echo "🗄️  Running migrations..."
              timeout 45 npx prisma migrate deploy 2>&1 | tail -3 || echo "⚠️  Migration skipped or failed"
              echo "$SCHEMA_HASH" > .prisma_hash
            else
              echo "⏭️  Schema unchanged"
            fi
          fi
          
          # Restart PM2
          echo "🔄 Restarting application..."
          pm2 delete jobportal 2>/dev/null || true
          pm2 start ecosystem.config.cjs --env production || {
            echo "❌ PM2 start failed"
            pm2 logs jobportal --lines 50 || true
            exit 1
          }
          sleep 2
          pm2 save --force >/dev/null 2>&1
          
          # Health check
          echo "🧪 Checking application health..."
          sleep 3
          if curl -f -s http://localhost:3000/api/health >/dev/null 2>&1; then
            echo "✅ Application is healthy"
          else
            echo "⚠️  Health check may have failed (this is sometimes expected)"
            pm2 logs jobportal --lines 10 || true
          fi
          
          END_TIME=$(date +%s)
          DURATION=$(expr $END_TIME - $START_TIME)
          echo "✅ Deployed in ${DURATION}s"
          exit 0
          DEPLOY_SCRIPT
          
          # Now execute via SSH with env vars properly passed
          echo "🚀 Executing deployment on remote server..."
          
          # Define SSH options with keepalive to prevent connection drops
          SSH_OPTS="-i ~/.ssh/deploy_key -p $DEPLOY_SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 -o BatchMode=yes"
          
          if ssh $SSH_OPTS \
            "$DEPLOY_SSH_USER@$DEPLOY_HOST" \
            "export NEXTAUTH_SECRET=\"$NEXTAUTH_SECRET\" && \
             export DATABASE_URL=\"$DATABASE_URL\" && \
             export GOOGLE_CLIENT_ID=\"$GOOGLE_CLIENT_ID\" && \
             export GOOGLE_CLIENT_SECRET=\"$GOOGLE_CLIENT_SECRET\" && \
             export OPENAI_API_KEY=\"$OPENAI_API_KEY\" && \
             export GEMINI_API_KEY=\"$GEMINI_API_KEY\" && \
             export GROQ_API_KEY=\"$GROQ_API_KEY\" && \
             export GOOGLE_CLOUD_OCR_API_KEY=\"$GOOGLE_CLOUD_OCR_API_KEY\" && \
             bash -s" < /tmp/deploy_script.sh; then
            echo "✅ Deployment script executed successfully"
          else
            DEPLOY_EXIT=$?
            echo ""
            echo "❌ Remote deployment failed with exit code $DEPLOY_EXIT"
            echo "This may be due to:"
            echo "  - Application startup issues (check PM2 logs on server)"
            echo "  - Database migration failures (check Prisma schema)"
            echo "  - Missing environment variables"
            exit 1
          fi
