name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    env:
      HOST: ${{ secrets.HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
      GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
      NPM_REGISTRY: https://registry.npmjs.org/
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify deployment secrets
        run: |
          echo "🔍 Verifying deployment configuration..."
          MISSING_SECRETS=()
          
          [ -z "${{ secrets.HOST }}" ] && MISSING_SECRETS+=("HOST")
          [ -z "${{ secrets.SSH_USER }}" ] && MISSING_SECRETS+=("SSH_USER")
          [ -z "${{ secrets.SSH_KEY }}" ] && MISSING_SECRETS+=("SSH_KEY")
          [ -z "${{ secrets.SSH_PORT }}" ] && MISSING_SECRETS+=("SSH_PORT")
          [ -z "${{ secrets.NEXTAUTH_SECRET }}" ] && MISSING_SECRETS+=("NEXTAUTH_SECRET")
          [ -z "${{ secrets.DATABASE_URL }}" ] && MISSING_SECRETS+=("DATABASE_URL")
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "❌ Missing required secrets: ${MISSING_SECRETS[*]}"
            echo "Please configure these in GitHub repository Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          echo "✅ All required secrets are configured"
          echo ""
          echo "📊 Secret Configuration Summary:"
          echo "  - HOST: ${{ secrets.HOST }}"
          echo "  - SSH_USER: ${{ secrets.SSH_USER }}"
          echo "  - SSH_PORT: ${{ secrets.SSH_PORT }}"
          echo "  - SSH_KEY format: $(echo '${{ secrets.SSH_KEY }}' | head -c 30)..."
          echo "  - SSH_KEY lines: $(echo '${{ secrets.SSH_KEY }}' | wc -l)"
          echo "  - SSH_KEY size: $(echo -n '${{ secrets.SSH_KEY }}' | wc -c) bytes"
          echo ""
          echo "🔑 SSH Key validation:"
          
          # Write key to temp file for validation
          echo "${{ secrets.SSH_KEY }}" > /tmp/ssh_key_test
          chmod 600 /tmp/ssh_key_test
          
          # Check key format
          if grep -q "BEGIN.*PRIVATE KEY" /tmp/ssh_key_test; then
            echo "  ✅ SSH key has valid header"
            KEY_TYPE=$(head -1 /tmp/ssh_key_test | sed 's/.*BEGIN \(.*\) PRIVATE.*/\1/')
            echo "  ✅ Key type: $KEY_TYPE"
          else
            echo "  ❌ SSH key format is INVALID - does not contain 'BEGIN ... PRIVATE KEY'"
            echo "  First line: $(head -1 /tmp/ssh_key_test)"
            echo "  Expected format: '-----BEGIN OPENSSH PRIVATE KEY-----' or similar"
            exit 1
          fi
          
          # Check key has END marker
          if grep -q "END.*PRIVATE KEY" /tmp/ssh_key_test; then
            echo "  ✅ SSH key has valid footer"
          else
            echo "  ❌ SSH key missing END marker"
            exit 1
          fi
          
          rm /tmp/ssh_key_test
          echo "✅ SSH key validation passed"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Configure npm (parallel optimizations)
        run: |
          npm config set registry "$NPM_REGISTRY"
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set maxsockets 128
          npm config set fetch-retries 1
          npm config set fetch-retry-mintimeout 1000

      - name: Install dependencies (build only)
        run: |
          npm ci --legacy-peer-deps --no-audit --prefer-offline 2>&1 | tail -3

      - name: Clean old Prisma generated client
        run: |
          echo "🧹 Removing any stale Prisma generated client output..."
          rm -rf lib/generated/prisma || true
          ls -lah lib || true

      - name: Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
        run: |
          echo "🔧 Generating Prisma Client..."
          # Capture full prisma generate output for debugging
          npx prisma generate --schema=prisma/schema.prisma 2>&1 | tee prisma-generate.log
          GEN_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}

          if [ $GEN_EXIT -ne 0 ]; then
            echo "❌ Prisma generation failed with exit code $GEN_EXIT"
            echo "===== Last 200 lines of prisma-generate.log ====="
            tail -n 200 prisma-generate.log || true
            echo "===== End prisma generate log ====="
            exit $GEN_EXIT
          fi

          # Check common locations for generated client
          if [ ! -d lib/generated/prisma/client ] && [ ! -d node_modules/.prisma/client ] && [ ! -d node_modules/@prisma/client ]; then
            echo "⚠️ Warning: Prisma client not found in expected locations. Listing directories for debugging:"
            ls -lah lib/generated/prisma || true
            ls -lah node_modules/.prisma || true
            ls -lah node_modules/@prisma || true
          else
            echo "✅ Prisma client generated successfully"
          fi

      - name: Build (production optimized)
        timeout-minutes: 8
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: https://naukrimili.com
          NEXT_PUBLIC_APP_URL: https://naukrimili.com
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          SKIP_BUILD_DB_QUERIES: true
          # Provide a syntactically valid fake DATABASE_URL so Prisma env("DATABASE_URL") resolves during build
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NODE_OPTIONS: --max-old-space-size=4096
          SWC_NUM_THREADS: 4
          ESLINT_NO_DEV_ERRORS: true
          GOOGLE_CLIENT_ID: ${{ env.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ env.GOOGLE_CLIENT_SECRET }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
        run: |
          echo "🔨 Starting production build..."
          echo "📍 Current directory: $(pwd)"
          echo "🔧 Node version: $(node --version)"
          echo "📦 npm version: $(npm --version)"
          
          # Configure npm for reliable builds
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set fetch-retries 3
          npm config set loglevel verbose
          
          # Run build and capture full output to build-output.log for CI artifacts
          # Explicitly pass all env vars to ensure they're available during build
          NEXTAUTH_SECRET="${NEXTAUTH_SECRET}" \
          NEXTAUTH_URL="https://naukrimili.com" \
          NEXT_PUBLIC_APP_URL="https://naukrimili.com" \
          GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID}" \
          GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET}" \
          OPENAI_API_KEY="${OPENAI_API_KEY}" \
          GEMINI_API_KEY="${GEMINI_API_KEY}" \
          GROQ_API_KEY="${GROQ_API_KEY}" \
          GOOGLE_CLOUD_OCR_API_KEY="${GOOGLE_CLOUD_OCR_API_KEY}" \
          NODE_ENV=production \
          NODE_OPTIONS="--max-old-space-size=4096" \
          NEXT_TELEMETRY_DISABLED=1 \
          SKIP_ENV_VALIDATION=1 \
          SKIP_DB_VALIDATION=true \
          SKIP_BUILD_DB_QUERIES=true \
          DATABASE_URL="postgresql://ci:ci@127.0.0.1:5432/ci" \
          npm run build:linux 2>&1 | tee build-output.log || true
          BUILD_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}

          # Fallback to standard Next.js build if custom script failed
          if [ $BUILD_EXIT -ne 0 ]; then
            echo "⚠️ build:linux failed with exit code $BUILD_EXIT, attempting fallback 'npm run build'"
            NEXTAUTH_SECRET="${NEXTAUTH_SECRET}" \
            NEXTAUTH_URL="https://naukrimili.com" \
            NEXT_PUBLIC_APP_URL="https://naukrimili.com" \
            GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID}" \
            GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET}" \
            OPENAI_API_KEY="${OPENAI_API_KEY}" \
            GEMINI_API_KEY="${GEMINI_API_KEY}" \
            GROQ_API_KEY="${GROQ_API_KEY}" \
            GOOGLE_CLOUD_OCR_API_KEY="${GOOGLE_CLOUD_OCR_API_KEY}" \
            NODE_ENV=production \
            NODE_OPTIONS="--max-old-space-size=4096" \
            NEXT_TELEMETRY_DISABLED=1 \
            SKIP_ENV_VALIDATION=1 \
            SKIP_DB_VALIDATION=true \
            SKIP_BUILD_DB_QUERIES=true \
            DATABASE_URL="postgresql://ci:ci@127.0.0.1:5432/ci" \
            npm run build 2>&1 | tee -a build-output.log || true
            FALLBACK_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}
            if [ $FALLBACK_EXIT -ne 0 ]; then
              echo "⚠️ fallback 'npm run build' failed, attempting 'npx next build'"
              npx next build 2>&1 | tee -a build-output.log || true
              BUILD_EXIT=${PIPESTATUS[0]:-${PIPESTATUS}}
            else
              BUILD_EXIT=$FALLBACK_EXIT
            fi
          fi
          
          if [ $BUILD_EXIT -ne 0 ]; then
            echo ""
            echo "❌ Build failed with exit code $BUILD_EXIT"
            echo ""
            echo "===== Last 200 lines of build-output.log ====="
            tail -n 200 build-output.log || true
            echo "===== End build log snippet ====="
            echo ""
            echo "📁 Directory contents after failed build:"
            ls -lah | head -30
            exit $BUILD_EXIT
          fi
          
          # Verify build output
          if [ ! -d .next ]; then
            echo "❌ CRITICAL: Build failed - .next directory not created"
            echo "📁 Current directory contents:"
            ls -lah
            echo ""
            echo "🔍 Total disk usage:"
            du -sh . | head -5
            exit 1
          fi
          
          NEXT_SIZE=$(du -sh .next | cut -f1)
          echo "✅ Build completed successfully"
          echo "📊 Build output size: $NEXT_SIZE"
          
          # Extra verification - count files in .next
          FILE_COUNT=$(find .next -type f | wc -l)
          echo "📈 Number of files in .next: $FILE_COUNT"
          
          if [ "$FILE_COUNT" -lt 100 ]; then
            echo "⚠️  WARNING: Unusually low file count in .next directory"
          fi

      - name: Upload build logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: |
            build-output.log

      - name: Prepare deployment bundle
        run: |
          echo "🔍 Checking build artifacts..."
          
          if [ ! -d .next ]; then
            echo "❌ CRITICAL: .next directory not found!"
            echo "📁 Current directory contents:"
            ls -lah | head -20
            exit 1
          fi
          
          echo "✅ .next directory found ($(du -sh .next | cut -f1))"
          
          DEPLOY_DIR="/tmp/naukrimili_deploy_$$"
          mkdir -p "$DEPLOY_DIR"
          
          # Copy only essential files
          echo "📋 Copying build artifacts..."
          cp -r .next "$DEPLOY_DIR/"
          find "$DEPLOY_DIR/.next" -name '*.map' -delete 2>/dev/null || true
          find "$DEPLOY_DIR/.next/cache" -type f -delete 2>/dev/null || true
          
          for file in package.json package-lock.json ecosystem.config.cjs next.config.mjs server.cjs; do
            if [ -f "$file" ]; then
              cp "$file" "$DEPLOY_DIR/"
              echo "  ✓ $file"
            fi
          done
          
          [ -d public ] && cp -r public "$DEPLOY_DIR/" && echo "  ✓ public/"
          [ -d prisma ] && cp -r prisma "$DEPLOY_DIR/" && echo "  ✓ prisma/"
          
          # Create tar.zst
          echo "📦 Creating deployment bundle..."
          cd "$DEPLOY_DIR"
          tar -I 'zstd -1 -T0' -cf ../release.tar.zst . || { echo "❌ tar failed"; exit 1; }
          cd - > /dev/null
          
          mv "$DEPLOY_DIR/release.tar.zst" release.tar.zst 2>/dev/null || mv "$DEPLOY_DIR/../release.tar.zst" release.tar.zst
          
          if [ ! -f release.tar.zst ]; then
            echo "❌ release.tar.zst not created"
            exit 1
          fi
          
          BUNDLE_SIZE=$(ls -lh release.tar.zst | awk '{print $5}')
          echo "✅ Bundle created: $BUNDLE_SIZE"
          
          # Verify bundle integrity
          if tar -I 'zstd -d -T0' -tf release.tar.zst | head -5 >/dev/null 2>&1; then
            echo "✅ Bundle integrity verified"
          else
            echo "❌ Bundle integrity check failed"
            exit 1
          fi
          
          rm -rf "$DEPLOY_DIR"

      - name: Test server connectivity
        run: |
          echo "🌐 Testing connectivity to server..."
          
          HOST="${{ env.HOST }}"
          SSH_PORT="${{ env.SSH_PORT }}"
          
          echo "Target: $HOST:$SSH_PORT"
          echo ""
          
          # Try netcat if available
          echo "Testing with netcat..."
          if command -v nc &> /dev/null; then
            if nc -zv -w 3 "$HOST" "$SSH_PORT" 2>&1; then
              echo "✅ Netcat: Connection successful on port $SSH_PORT"
            else
              NETCAT_RESULT=$?
              echo "⚠️ Netcat: Connection failed (exit code $NETCAT_RESULT)"
            fi
          else
            echo "⚠️ netcat not available"
          fi
          
          echo ""
          echo "Testing with bash TCP socket..."
          
          # Test using bash TCP socket (timeout = 5 seconds)
          (sleep 5; exec 3<>/dev/tcp/"$HOST"/"$SSH_PORT") 2>/dev/null && {
            exec 3>&-
            echo "✅ Bash TCP: Connection successful on port $SSH_PORT"
          } || {
            TCP_RESULT=$?
            echo "❌ Bash TCP: Connection FAILED on port $SSH_PORT"
            echo "   Error code: $TCP_RESULT"
            echo ""
            echo "⚠️ IMPORTANT: This means the server is NOT REACHABLE at $HOST:$SSH_PORT"
            echo ""
            echo "🔍 Diagnostics - Please verify:"
            echo "   1. HOST environment variable is set correctly: '$HOST'"
            echo "   2. SSH_PORT environment variable is correct: '$SSH_PORT'"
            echo "   3. Server is running and accepting SSH connections"
            echo "   4. Firewall/Security Groups allow inbound traffic on port $SSH_PORT"
            echo "   5. GitHub Actions IP is not blocked (check server firewall logs)"
            echo ""
            echo "💡 Debug commands to run on your LOCAL machine:"
            echo "   ssh -v -p $SSH_PORT your-user@$HOST"
            echo "   Or: telnet $HOST $SSH_PORT"
            echo ""
            exit 1
          }

      - name: Fast upload and deploy
        run: |
          set -e
          
          echo "🔍 Pre-flight checks..."
          
          # Check bundle exists
          if [ ! -f release.tar.zst ]; then
            echo "❌ ERROR: release.tar.zst not found in current directory"
            echo "📁 Current directory:"
            ls -lah | grep -E "tar.zst|release|\.next"
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.zst | cut -f1)
          echo "✅ Bundle found: $BUNDLE_SIZE"
          
          # Check required commands
          echo "🔧 Checking required tools..."
          for cmd in ssh rsync zstd tar; do
            if ! command -v $cmd >/dev/null 2>&1; then
              echo "❌ ERROR: $cmd not found"
              exit 1
            else
              echo "  ✓ $cmd available"
            fi
          done
          
          # Verify required secrets
          echo "🔐 Verifying secrets..."
          SECRETS_OK=true
          [ -z "${{ env.SSH_KEY }}" ] && echo "❌ Missing SSH_KEY" && SECRETS_OK=false
          [ -z "${{ env.SSH_USER }}" ] && echo "❌ Missing SSH_USER" && SECRETS_OK=false
          [ -z "${{ env.HOST }}" ] && echo "❌ Missing HOST" && SECRETS_OK=false
          [ -z "${{ env.SSH_PORT }}" ] && echo "❌ Missing SSH_PORT" && SECRETS_OK=false
          
          if [ "$SECRETS_OK" = false ]; then
            echo "❌ Secrets verification failed"
            exit 1
          fi
          echo "✅ All secrets present"
          
          # Setup SSH
          echo "🔑 Setting up SSH..."
          mkdir -p ~/.ssh
          echo "${{ env.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key format
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "⚠️  WARNING: SSH key format may be incorrect"
            echo "First 50 chars: $(head -c 50 ~/.ssh/deploy_key)"
          fi
          
          echo "🌐 Scanning SSH host keys..."
          if ! ssh-keyscan -p ${{ env.SSH_PORT }} -T 5 ${{ env.HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "⚠️  ssh-keyscan failed, continuing anyway..."
            echo "ssh-keyscan output:"
            ssh-keyscan -p ${{ env.SSH_PORT }} -T 5 ${{ env.HOST }} 2>&1 | head -20 || true
          fi
          
          echo "🧪 Testing SSH connection..."
          SSH_TEST=$(ssh -i ~/.ssh/deploy_key \
            -p ${{ env.SSH_PORT }} \
            -o StrictHostKeyChecking=accept-new \
            -o ConnectTimeout=15 \
            -o BatchMode=yes \
            -v \
            ${{ env.SSH_USER }}@${{ env.HOST }} "echo 'SSH_OK' && pwd" 2>&1) || {
            echo "❌ SSH connection test failed"
            echo "SSH output:"
            echo "$SSH_TEST"
            exit 1
          }
          
          echo "✅ SSH connection successful"
          echo "Remote directory: $(echo "$SSH_TEST" | grep -v 'debug' | tail -1)"
          
          echo "📤 Starting rsync upload..."
          echo "Source: release.tar.zst ($BUNDLE_SIZE)"
          echo "Target: ${{ env.SSH_USER }}@${{ env.HOST }}:/var/www/naukrimili/"
          
          if ! rsync -avz --progress --partial \
            -e "ssh -i ~/.ssh/deploy_key -p ${{ env.SSH_PORT }} -o StrictHostKeyChecking=accept-new" \
            release.tar.zst ${{ env.SSH_USER }}@${{ env.HOST }}:/var/www/naukrimili/ 2>&1 | tee rsync.log; then
            echo "❌ rsync upload failed"
            echo "Last 30 lines of rsync output:"
            tail -30 rsync.log
            exit 1
          fi
          
          echo "✅ Upload complete"

      - name: Upload deployment logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: |
            rsync.log
            ssh-debug.log
          retention-days: 7

      - name: Deploy via SSH (ultra-fast)
        env:
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          DATABASE_URL: ${{ env.DATABASE_URL }}
          GOOGLE_CLIENT_ID: ${{ env.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ env.GOOGLE_CLIENT_SECRET }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ env.SSH_PORT }} \
            -o StrictHostKeyChecking=accept-new \
            -o ConnectTimeout=15 \
            ${{ env.SSH_USER }}@${{ env.HOST }} \
            "NEXTAUTH_SECRET='$NEXTAUTH_SECRET' \
             DATABASE_URL='$DATABASE_URL' \
             GOOGLE_CLIENT_ID='$GOOGLE_CLIENT_ID' \
             GOOGLE_CLIENT_SECRET='$GOOGLE_CLIENT_SECRET' \
             OPENAI_API_KEY='$OPENAI_API_KEY' \
             GEMINI_API_KEY='$GEMINI_API_KEY' \
             GROQ_API_KEY='$GROQ_API_KEY' \
             GOOGLE_CLOUD_OCR_API_KEY='$GOOGLE_CLOUD_OCR_API_KEY' \
             bash -s <<'DEPLOY_SCRIPT'
          set -euo pipefail
          
          # Enable error handling
          trap 'echo "❌ Deployment failed at line $LINENO"; exit 1' ERR
          
          START_TIME=$(date +%s)
          DEPLOY_PATH="/var/www/naukrimili"
          
          # Verify deploy directory exists
          if [ ! -d "$DEPLOY_PATH" ]; then
            echo "❌ ERROR: Deploy directory $DEPLOY_PATH does not exist"
            ls -la /var/www/ 2>/dev/null || echo "❌ Cannot read /var/www/"
            exit 1
          fi
          
          cd "$DEPLOY_PATH"
          echo "⚡ Fast deployment started in $DEPLOY_PATH"
          
          # Check for bundle
          if [ ! -f "release.tar.zst" ]; then
            echo "❌ ERROR: release.tar.zst not found in $DEPLOY_PATH"
            echo "📁 Current directory contents:"
            ls -lah | head -20
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.zst | cut -f1)
          echo "📦 Found bundle: $BUNDLE_SIZE"
          
          # Install zstd if missing
          if ! command -v zstd >/dev/null 2>&1; then
            echo "⚠️  zstd not found, installing..."
            apt-get update -qq 2>/dev/null || true
            apt-get install -y zstd >/dev/null 2>&1 || {
              echo "⚠️  Failed to install zstd, attempting decompression anyway..."
            }
          fi
          
          # Extract
          echo "📦 Extracting bundle..."
          if ! tar -I 'zstd -d -T0' -xf release.tar.zst; then
            echo "❌ Failed to extract release.tar.zst"
            echo "Attempting to check bundle integrity..."
            tar -I 'zstd -d -T0' -tzf release.tar.zst 2>&1 | head -20 || true
            exit 1
          fi
          
          echo "✅ Bundle extracted"
          rm -f release.tar.zst
          
          # Verify extracted files
          if [ ! -d .next ]; then
            echo "❌ .next directory not found after extraction"
            ls -lah | grep -E "next|app" || echo "No .next/app files found"
            exit 1
          fi
          
          echo "✅ Build artifacts verified"
          
          # Ultra-fast dependency handling
          LOCKFILE_HASH=$(md5sum package-lock.json 2>/dev/null | cut -d' ' -f1)
          PREV_HASH=$(cat .lock_hash 2>/dev/null || echo "none")
          
          if [ -d node_modules ] && [ "$LOCKFILE_HASH" = "$PREV_HASH" ]; then
            echo "⏭️  Skipping npm install (unchanged)"
          else
            echo "📚 Installing production deps..."
            # Configure npm for maximum speed
            npm config set cache /var/www/naukrimili/.npm-cache
            npm config set registry https://registry.npmjs.org/
            npm config set prefer-offline true
            npm config set fund false
            npm config set audit false
            npm config set progress false
            npm config set fetch-retries 2
            npm config set fetch-retry-mintimeout 500
            npm config set fetch-retry-maxtimeout 2000
            npm config set maxsockets 100
            npm config set loglevel error
            
            # Use npm install for faster execution on server (incremental)
            if ! timeout 90 npm install --omit=dev --no-audit --prefer-offline --no-fund --loglevel=error 2>&1 | tail -5; then
              echo "⚠️  npm install failed/slow, trying clean install..."
              rm -rf node_modules package-lock.json
              if ! timeout 120 npm install --omit=dev --no-audit --no-fund --loglevel=error 2>&1 | tail -5; then
                echo "❌ npm install failed"
                exit 1
              fi
            fi
            echo "$LOCKFILE_HASH" > .lock_hash
          fi
          
          # Set env vars
          export NODE_ENV=production \
                 NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
                 NEXTAUTH_URL=https://naukrimili.com \
                 NEXT_PUBLIC_APP_URL=https://naukrimili.com \
                 DATABASE_URL="$DATABASE_URL" \
                 NEXT_TELEMETRY_DISABLED=1 \
                 GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
                 GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET" \
                 OPENAI_API_KEY="$OPENAI_API_KEY" \
                 GEMINI_API_KEY="$GEMINI_API_KEY" \
                 GROQ_API_KEY="$GROQ_API_KEY" \
                 GOOGLE_CLOUD_OCR_API_KEY="$GOOGLE_CLOUD_OCR_API_KEY"
          
          # Migrations (skip if unchanged)
          if [ -f prisma/schema.prisma ]; then
            SCHEMA_HASH=$(md5sum prisma/schema.prisma 2>/dev/null | cut -d' ' -f1)
            if [ "$SCHEMA_HASH" != "$(cat .prisma_hash 2>/dev/null)" ]; then
              echo "🗄️  Running migrations..."
              timeout 45 npx prisma migrate deploy 2>&1 | tail -3 || echo "⚠️  Migration skipped or failed"
              echo "$SCHEMA_HASH" > .prisma_hash
            else
              echo "⏭️  Schema unchanged"
            fi
          fi
          
          # Restart PM2
          echo "🔄 Restarting application..."
          pm2 delete jobportal 2>/dev/null || true
          pm2 start ecosystem.config.cjs --env production || {
            echo "❌ PM2 start failed"
            pm2 logs jobportal --lines 50 || true
            exit 1
          }
          sleep 2
          pm2 save --force >/dev/null 2>&1
          
          # Health check
          echo "🧪 Checking application health..."
          sleep 3
          if curl -f -s http://localhost:3000/api/health >/dev/null 2>&1; then
            echo "✅ Application is healthy"
          else
            echo "⚠️  Health check may have failed (this is sometimes expected)"
            pm2 logs jobportal --lines 10 || true
          fi
          
          END_TIME=$(date +%s)
          DURATION=$(expr $END_TIME - $START_TIME)
          echo "✅ Deployed in ${DURATION}s"
          exit 0
          DEPLOY_SCRIPT
