name: Deploy to Production (Zero-Downtime)

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  validate_and_deploy:
    name: Validate Secrets & Deploy with Zero Downtime
    runs-on: ubuntu-latest
    env:
      HOST: ${{ secrets.HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
      GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
      NPM_REGISTRY: https://registry.npmjs.org/
      DEPLOY_FOLDER: /var/www/naukrimili
      STAGING_FOLDER: /var/www/naukrimili-staging
      START_TIME: ${{ github.run_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: 🔐 VALIDATE ALL SECRETS (Critical Step)
        run: |
          set +e  # Continue on error to show all issues
          echo "════════════════════════════════════════════════════════════════"
          echo "🔐 CRITICAL: VALIDATING ALL PRODUCTION SECRETS"
          echo "════════════════════════════════════════════════════════════════"
          echo ""
          
          MISSING_SECRETS=0
          INVALID_SECRETS=0
          
          # Function to check secret
          check_secret() {
            local name=$1
            local value=$2
            local min_len=${3:-1}
            local pattern=${4:-""}
            
            if [ -z "$value" ]; then
              echo "❌ $name: MISSING (empty)"
              ((MISSING_SECRETS++))
              return 1
            fi
            
            local len=$(echo -n "$value" | wc -c)
            echo "✅ $name: SET ($len chars)"
            
            if [ $len -lt $min_len ]; then
              echo "   ⚠️  WARNING: Too short (min: $min_len)"
              ((INVALID_SECRETS++))
            fi
            
            if [ -n "$pattern" ] && ! echo "$value" | grep -qE "$pattern"; then
              echo "   ⚠️  WARNING: Invalid format"
              ((INVALID_SECRETS++))
            fi
            
            return 0
          }
          
          # Check all deployment secrets
          check_secret "HOST" "$HOST" 5
          check_secret "SSH_USER" "$SSH_USER" 1
          check_secret "SSH_PORT" "$SSH_PORT" 1 "^[0-9]+$"
          check_secret "SSH_KEY" "$SSH_KEY" 100 "BEGIN.*PRIVATE"
          check_secret "NEXTAUTH_SECRET" "$NEXTAUTH_SECRET" 32
          check_secret "DATABASE_URL" "$DATABASE_URL" 20 "postgresql://"
          
          # Check OAuth secrets
          check_secret "GOOGLE_CLIENT_ID" "$GOOGLE_CLIENT_ID" 10
          check_secret "GOOGLE_CLIENT_SECRET" "$GOOGLE_CLIENT_SECRET" 10
          
          # Check optional AI keys
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "⚠️  OPENAI_API_KEY: OPTIONAL (not set)"
          else
            echo "✅ OPENAI_API_KEY: SET (${#OPENAI_API_KEY} chars)"
          fi
          
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "⚠️  GEMINI_API_KEY: OPTIONAL (not set)"
          else
            echo "✅ GEMINI_API_KEY: SET (${#GEMINI_API_KEY} chars)"
          fi
          
          echo ""
          if [ $MISSING_SECRETS -gt 0 ]; then
            echo "════════════════════════════════════════════════════════════════"
            echo "❌ DEPLOYMENT BLOCKED: $MISSING_SECRETS missing secrets!"
            echo "════════════════════════════════════════════════════════════════"
            echo ""
            echo "📋 REQUIRED SECRETS:"
            echo ""
            echo "1. HOST = srv1054971.hstgr.cloud (or your domain)"
            echo "2. SSH_USER = root"
            echo "3. SSH_PORT = 22"
            echo "4. SSH_KEY = (complete private key from -----BEGIN to -----END)"
            echo "5. NEXTAUTH_SECRET = (32+ random characters)"
            echo "6. DATABASE_URL = postgresql://user:pass@host:5432/dbname"
            echo "7. GOOGLE_CLIENT_ID"
            echo "8. GOOGLE_CLIENT_SECRET"
            echo ""
            echo "🔧 TO FIX:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Click 'New repository secret' for each missing secret"
            echo "3. Re-run this workflow"
            echo ""
            exit 1
          fi
          
          if [ $INVALID_SECRETS -gt 0 ]; then
            echo "⚠️  $INVALID_SECRETS secret(s) may be invalid. Continuing with caution..."
            echo ""
          else
            echo "✅ ALL SECRETS VALIDATED SUCCESSFULLY"
          fi
          echo "════════════════════════════════════════════════════════════════"
          echo ""

      - name: 🔑 Setup SSH Key (Proper Format)
        run: |
          echo "🔑 Setting up SSH key with proper format..."
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key, handling both escaped newlines and real newlines
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          
          # Remove any CRLF line endings (Windows format)
          dos2unix ~/.ssh/deploy_key 2>/dev/null || sed -i 's/\r$//' ~/.ssh/deploy_key
          
          # Validate SSH key format
          if ! grep -q "BEGIN.*PRIVATE" ~/.ssh/deploy_key; then
            echo "❌ SSH_KEY is not in valid OpenSSH format"
            echo "🔍 First 100 chars of key:"
            head -c 100 ~/.ssh/deploy_key
            echo ""
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE" ~/.ssh/deploy_key; then
            echo "❌ SSH_KEY missing END marker"
            exit 1
          fi
          
          # Set correct permissions
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file integrity
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          if [ $KEY_SIZE -lt 1000 ]; then
            echo "⚠️  SSH key seems small ($KEY_SIZE bytes). This might be an issue."
          fi
          
          echo "✅ SSH key written ($KEY_SIZE bytes)"
          echo "✅ Permissions set to 600"

      - name: 🧪 Test SSH Connection
        run: |
          set -e
          
          echo "🧪 Testing SSH connection to $HOST:$SSH_PORT..."
          
          # Validate secrets are present
          if [ -z "$HOST" ] || [ -z "$SSH_USER" ] || [ -z "$SSH_PORT" ]; then
            echo "❌ Missing SSH configuration"
            exit 1
          fi
          
          # SSH options for reliability
          SSH_OPTS="-i ~/.ssh/deploy_key \
                   -p $SSH_PORT \
                   -o StrictHostKeyChecking=accept-new \
                   -o ConnectTimeout=15 \
                   -o IdentitiesOnly=yes \
                   -o BatchMode=yes \
                   -o ServerAliveInterval=60"
          
          # Test SSH connection
          echo "Testing SSH login..."
          if ! ssh $SSH_OPTS "$SSH_USER@$HOST" "echo '✅ SSH Connection OK' && uname -a"; then
            echo ""
            echo "❌ SSH CONNECTION FAILED"
            echo ""
            echo "Common issues:"
            echo "  1. SSH_KEY is not a valid private key"
            echo "  2. HOST is incorrect"
            echo "  3. SSH_USER is incorrect"  
            echo "  4. SSH_PORT is wrong"
            echo "  5. Server firewall blocks GitHub Actions IP"
            echo ""
            echo "💡 Local test command:"
            echo "   ssh -i /path/to/private_key -p $SSH_PORT $SSH_USER@$HOST"
            exit 1
          fi
          
          echo ""
          echo "✅ SSH connection verified"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: 📦 Install Dependencies (Production Only)
        run: |
          echo "📦 Installing production dependencies..."
          npm config set registry "$NPM_REGISTRY"
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set maxsockets 128
          npm config set fetch-retries 3
          npm config set fetch-retry-mintimeout 2000
          
          # Clean install with explicit production mode
          npm ci --omit=dev --legacy-peer-deps --no-audit 2>&1 | tail -5
          
          if [ ! -d node_modules ]; then
            echo "❌ CRITICAL: npm install failed - no node_modules"
            exit 1
          fi
          
          echo "✅ Dependencies installed"

      - name: 🔧 Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
        run: |
          echo "🔧 Generating Prisma Client from schema..."
          
          # Verify schema exists
          if [ ! -f prisma/schema.prisma ]; then
            echo "❌ CRITICAL: prisma/schema.prisma not found!"
            exit 1
          fi
          
          # Clean any old generated client
          rm -rf lib/generated/prisma 2>/dev/null || true
          rm -rf .prisma/client 2>/dev/null || true
          
          # Generate Prisma client
          npx prisma generate --schema=prisma/schema.prisma 2>&1 | tee prisma-generate.log
          GEN_EXIT=${PIPESTATUS[0]}
          
          if [ $GEN_EXIT -ne 0 ]; then
            echo ""
            echo "❌ Prisma generation failed!"
            tail -50 prisma-generate.log
            exit $GEN_EXIT
          fi
          
          # Verify Prisma client exists in at least one location
          if [ ! -d node_modules/.prisma/client ] && \
             [ ! -d node_modules/@prisma/client ] && \
             [ ! -d lib/generated/prisma ]; then
            echo "❌ CRITICAL: Prisma client not found after generation"
            echo "Searched in: node_modules/.prisma, node_modules/@prisma, lib/generated/prisma"
            find node_modules -name "prisma" -type d 2>/dev/null | head -10 || echo "No prisma dir found"
            exit 1
          fi
          
          echo "✅ Prisma client generated successfully"

      - name: 🔨 Build Next.js (Production Hardened)
        timeout-minutes: 12
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: https://naukrimili.com
          NEXT_PUBLIC_APP_URL: https://naukrimili.com
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NODE_OPTIONS: --max-old-space-size=6144
          SWC_NUM_THREADS: 4
          ESLINT_NO_DEV_ERRORS: true
          GOOGLE_CLIENT_ID: ${{ env.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ env.GOOGLE_CLIENT_SECRET }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ env.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ env.GOOGLE_CLOUD_OCR_API_KEY }}
        run: |
          echo "🔨 Building Next.js application..."
          echo "📍 Node: $(node --version), npm: $(npm --version)"
          
          # Primary build attempt
          if npm run build 2>&1 | tee build.log; then
            echo "✅ Build succeeded on first attempt"
          else
            BUILD_EXIT=$?
            echo ""
            echo "⚠️  Build failed (exit $BUILD_EXIT), attempting npx next build..."
            
            # Fallback: direct Next.js build
            if npx next build 2>&1 | tee -a build.log; then
              echo "✅ Fallback build succeeded"
            else
              FALLBACK_EXIT=$?
              echo ""
              echo "❌ Both builds failed"
              echo "Last 100 lines of build.log:"
              tail -100 build.log
              exit $FALLBACK_EXIT
            fi
          fi
          
          # CRITICAL: Verify .next directory exists and is not empty
          if [ ! -d .next ]; then
            echo "❌ CRITICAL: .next directory not created!"
            ls -lah
            exit 1
          fi
          
          NEXT_SIZE=$(du -sh .next | cut -f1)
          FILE_COUNT=$(find .next -type f 2>/dev/null | wc -l)
          
          if [ "$FILE_COUNT" -lt 50 ]; then
            echo "❌ CRITICAL: .next directory appears empty ($FILE_COUNT files)"
            echo "📁 .next contents:"
            ls -lah .next | head -20
            exit 1
          fi
          
          echo "✅ Build artifacts verified"
          echo "   Size: $NEXT_SIZE"
          echo "   Files: $FILE_COUNT"

      - name: 📦 Create Deployment Bundle
        run: |
          echo "📦 Creating deployment bundle..."
          
          # Verify build artifacts
          if [ ! -d .next ]; then
            echo "❌ .next directory missing before bundling!"
            exit 1
          fi
          
          FILE_COUNT=$(find .next -type f | wc -l)
          if [ "$FILE_COUNT" -lt 50 ]; then
            echo "❌ .next directory is nearly empty ($FILE_COUNT files)"
            exit 1
          fi
          
          # Create clean bundle
          BUNDLE_DIR="/tmp/deploy-bundle-$$"
          mkdir -p "$BUNDLE_DIR"
          
          echo "Copying build artifacts..."
          cp -r .next "$BUNDLE_DIR/"
          
          # Remove unnecessary files
          find "$BUNDLE_DIR/.next" -name "*.map" -delete 2>/dev/null || true
          find "$BUNDLE_DIR/.next/cache" -type f -delete 2>/dev/null || true
          
          # Copy essential files
          for file in package.json package-lock.json ecosystem.config.cjs next.config.mjs server.cjs; do
            [ -f "$file" ] && cp "$file" "$BUNDLE_DIR/"
          done
          
          [ -d public ] && cp -r public "$BUNDLE_DIR/"
          [ -d prisma ] && cp -r prisma "$BUNDLE_DIR/"
          
          echo "Creating compressed archive..."
          cd "$BUNDLE_DIR"
          tar -czf ../release.tar.gz . || {
            echo "❌ tar failed"
            cd -
            exit 1
          }
          cd - > /dev/null
          
          mv "$BUNDLE_DIR/release.tar.gz" release.tar.gz 2>/dev/null || \
            mv /tmp/release.tar.gz . 2>/dev/null || {
            echo "❌ Failed to create bundle"
            exit 1
          }
          
          if [ ! -f release.tar.gz ]; then
            echo "❌ release.tar.gz not created"
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.gz | cut -f1)
          echo "✅ Bundle created: $BUNDLE_SIZE"
          
          rm -rf "$BUNDLE_DIR"

      - name: 📤 Upload Build Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            build.log
            prisma-generate.log
          retention-days: 7

      - name: Test server connectivity
        env:
          TEST_HOST: ${{ secrets.HOST }}
          TEST_PORT: ${{ secrets.SSH_PORT }}
        run: |
          echo "🌐 Testing connectivity to server..."
          
          HOST="$TEST_HOST"
          SSH_PORT="$TEST_PORT"
          
          # Validate secrets are not empty
          if [ -z "$HOST" ]; then
            echo "❌ ERROR: HOST secret is empty or not set"
            echo "   Please configure HOST in GitHub Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          if [ -z "$SSH_PORT" ]; then
            echo "❌ ERROR: SSH_PORT secret is empty or not set"
            echo "   Please configure SSH_PORT in GitHub Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          echo "Target: $HOST:$SSH_PORT"
          echo ""
          
          # Try netcat if available
          echo "Testing with netcat..."
          if command -v nc &> /dev/null; then
            if nc -zv -w 3 "$HOST" "$SSH_PORT" 2>&1; then
              echo "✅ Netcat: Connection successful on port $SSH_PORT"
            else
              NETCAT_RESULT=$?
              echo "⚠️ Netcat: Connection failed (exit code $NETCAT_RESULT)"
            fi
          else
            echo "⚠️ netcat not available"
          fi
          
          echo ""
          echo "Testing with bash TCP socket..."
          
          # Test using bash TCP socket (timeout = 5 seconds)
          (sleep 5; exec 3<>/dev/tcp/"$HOST"/"$SSH_PORT") 2>/dev/null && {
            exec 3>&-
            echo "✅ Bash TCP: Connection successful on port $SSH_PORT"
          } || {
            TCP_RESULT=$?
            echo "❌ Bash TCP: Connection FAILED on port $SSH_PORT"
            echo "   Error code: $TCP_RESULT"
            echo ""
            echo "⚠️ IMPORTANT: This means the server is NOT REACHABLE at $HOST:$SSH_PORT"
            echo ""
            echo "🔍 Configuration verification:"
            echo "   - HOST: $HOST"
            echo "   - SSH_PORT: $SSH_PORT"
            echo ""
            echo "🔍 Possible causes:"
            echo "   1. HOST secret is incorrect (check GitHub Secrets)"
            echo "   2. SSH_PORT secret is incorrect or missing"
            echo "   3. Server is not running or not accepting SSH connections"
            echo "   4. Firewall/Security Groups blocking inbound traffic on port $SSH_PORT"
            echo "   5. GitHub Actions IP is blocked by server firewall"
            echo ""
            echo "💡 Debug commands to run on YOUR LOCAL machine:"
            echo "   ssh -v -p $SSH_PORT your-user@$HOST"
            echo "   Or: nc -zv $HOST $SSH_PORT"
            echo "   Or: telnet $HOST $SSH_PORT"
            echo ""
            echo "🆘 If local SSH works but GitHub Actions fails:"
            echo "   - GitHub Actions runners may be blocked by your server's firewall"
            echo "   - Contact your hosting provider to whitelist GitHub's IP ranges"
            echo ""
            exit 1
          }

      - name: Fast upload and deploy
        env:
          FINAL_HOST: ${{ secrets.HOST }}
          FINAL_USER: ${{ secrets.SSH_USER }}
          FINAL_PORT: ${{ secrets.SSH_PORT }}
          FINAL_KEY: ${{ secrets.SSH_KEY }}
        run: |
          set -e
          
          echo "🔍 Checking secrets..."
          MISSING=0
          
          # Test each secret by length (empty = 0 chars)
          HOST_LEN=$(echo -n "$FINAL_HOST" | wc -c)
          USER_LEN=$(echo -n "$FINAL_USER" | wc -c)
          PORT_LEN=$(echo -n "$FINAL_PORT" | wc -c)
          KEY_LEN=$(echo -n "$FINAL_KEY" | wc -c)
          
          echo "HOST: $HOST_LEN chars"
          echo "SSH_USER: $USER_LEN chars"
          echo "SSH_PORT: $PORT_LEN chars"
          echo "SSH_KEY: $KEY_LEN chars"
          
          if [ $HOST_LEN -eq 0 ]; then echo "❌ HOST is empty"; MISSING=1; fi
          if [ $USER_LEN -eq 0 ]; then echo "❌ SSH_USER is empty"; MISSING=1; fi
          if [ $PORT_LEN -eq 0 ]; then echo "❌ SSH_PORT is empty"; MISSING=1; fi
          if [ $KEY_LEN -eq 0 ]; then echo "❌ SSH_KEY is empty"; MISSING=1; fi
          
          if [ $MISSING -eq 1 ]; then
            echo ""
            echo "Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "Add these secrets:"
            echo "  HOST = srv1054971.hstgr.cloud"
            echo "  SSH_USER = root"
            echo "  SSH_PORT = 22"
            echo "  SSH_KEY = (full private key from -----BEGIN to -----END)"
            exit 1
          fi
          
          echo "✅ All secrets present"
          
          # Check bundle exists
          if [ ! -f release.tar.zst ]; then
            echo "❌ release.tar.zst not found"
            exit 1
          fi
          
          # Check bundle exists
          if [ ! -f release.tar.zst ]; then
            echo "❌ ERROR: release.tar.zst not found in current directory"
            echo "📁 Current directory:"
            ls -lah | grep -E "tar.zst|release|\.next"
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.zst | cut -f1)
          echo "✅ Bundle found: $BUNDLE_SIZE"
          
          # Check required commands
          echo "🔧 Checking required tools..."
          for cmd in ssh rsync zstd tar; do
            if ! command -v $cmd >/dev/null 2>&1; then
              echo "❌ ERROR: $cmd not found"
              exit 1
            else
              echo "  ✓ $cmd available"
            fi
          done
          
          echo "✅ All secrets present"
          
          # Setup SSH
          echo "🔑 Setting up SSH..."
          mkdir -p ~/.ssh
          
          # Write key converting escaped \n to real newlines if present
          printf '%b' "$FINAL_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "❌ SSH key file is empty"
            exit 1
          fi
          
          echo "✅ SSH key written ($(wc -c < ~/.ssh/deploy_key) bytes)"
          
          echo "🧪 Testing SSH connection..."
          if ssh -i ~/.ssh/deploy_key \
            -p "$FINAL_PORT" \
            -o StrictHostKeyChecking=accept-new \
            -o ConnectTimeout=15 \
            -o IdentitiesOnly=yes \
            "$FINAL_USER@$FINAL_HOST" "echo connected" >/dev/null 2>&1; then
            echo "✅ SSH verified"
          else
            echo "❌ SSH connection failed"
            exit 1
          fi
          
          SSH_OPTS="-i ~/.ssh/deploy_key -p $FINAL_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          echo "🚀 Uploading to $FINAL_USER@$FINAL_HOST..."
          if rsync -avz --progress --partial \
            -e "ssh $SSH_OPTS" \
            release.tar.zst "$FINAL_USER@$FINAL_HOST:/var/www/naukrimili/" 2>&1 | tail -5; then
            echo "✅ Upload complete"
          else
            echo "❌ rsync upload failed"
            exit 1
          fi

      - name: Upload deployment logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: rsync.log
          retention-days: 3

      - name: Deploy via SSH (ultra-fast)
        env:
          FINAL_HOST: ${{ secrets.HOST }}
          FINAL_USER: ${{ secrets.SSH_USER }}
          FINAL_PORT: ${{ secrets.SSH_PORT }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
        run: |
          # Create deployment script with env vars embedded
          cat > /tmp/deploy_script.sh <<'DEPLOY_SCRIPT'
          set -euo pipefail
          
          # Validate deployment host before executing remote script
          if [ -z "${FINAL_HOST:-}" ] || [ -z "${FINAL_USER:-}" ] || [ -z "${FINAL_PORT:-}" ]; then
            echo "❌ ERROR: Missing deployment secrets (FINAL_HOST, FINAL_USER, FINAL_PORT)"
            exit 1
          fi
          
          DEPLOY_PATH="/var/www/naukrimili"
          
          # Verify deploy directory exists
          if [ ! -d "$DEPLOY_PATH" ]; then
            echo "❌ ERROR: Deploy directory $DEPLOY_PATH does not exist"
            ls -la /var/www/ 2>/dev/null || echo "❌ Cannot read /var/www/"
            exit 1
          fi
          
          cd "$DEPLOY_PATH"
          echo "⚡ Fast deployment started in $DEPLOY_PATH"
          
          # Check for bundle
          if [ ! -f "release.tar.zst" ]; then
            echo "❌ ERROR: release.tar.zst not found in $DEPLOY_PATH"
            echo "📁 Current directory contents:"
            ls -lah | head -20
            exit 1
          fi
          
          BUNDLE_SIZE=$(du -h release.tar.zst | cut -f1)
          echo "📦 Found bundle: $BUNDLE_SIZE"
          
          # Install zstd if missing
          if ! command -v zstd >/dev/null 2>&1; then
            echo "⚠️  zstd not found, installing..."
            apt-get update -qq 2>/dev/null || true
            apt-get install -y zstd >/dev/null 2>&1 || {
              echo "⚠️  Failed to install zstd, attempting decompression anyway..."
            }
          fi
          
          # Extract
          echo "📦 Extracting bundle..."
          if ! tar -I 'zstd -d -T0' -xf release.tar.zst; then
            echo "❌ Failed to extract release.tar.zst"
            echo "Attempting to check bundle integrity..."
            tar -I 'zstd -d -T0' -tzf release.tar.zst 2>&1 | head -20 || true
            exit 1
          fi
          
          echo "✅ Bundle extracted"
          rm -f release.tar.zst
          
          # Verify extracted files
          if [ ! -d .next ]; then
            echo "❌ .next directory not found after extraction"
            ls -lah | grep -E "next|app" || echo "No .next/app files found"
            exit 1
          fi
          
          echo "✅ Build artifacts verified"
          
          # Ultra-fast dependency handling
          LOCKFILE_HASH=$(md5sum package-lock.json 2>/dev/null | cut -d' ' -f1)
          PREV_HASH=$(cat .lock_hash 2>/dev/null || echo "none")
          
          if [ -d node_modules ] && [ "$LOCKFILE_HASH" = "$PREV_HASH" ]; then
            echo "⏭️  Skipping npm install (unchanged)"
          else
            echo "📚 Installing production deps..."
            
            # Configure npm for maximum speed with verbose output for debugging
            npm config set cache /var/www/naukrimili/.npm-cache --global
            npm config set registry https://registry.npmjs.org/ --global
            npm config set prefer-offline true --global
            npm config set fund false --global
            npm config set audit false --global
            npm config set progress false --global
            npm config set fetch-retries 3 --global
            npm config set fetch-retry-mintimeout 1000 --global
            npm config set fetch-retry-maxtimeout 3000 --global
            npm config set maxsockets 50 --global
            npm config set loglevel warn --global
            
            # Skip puppeteer, tesseract, and other dev-only packages downloads
            export PUPPETEER_SKIP_DOWNLOAD=true
            export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
            export TESSERACT_SKIP_DOWNLOAD=true
            export npm_config_ignore_scripts=false
            export SKIP_POSTINSTALL=1
            
            # Check if we already have node_modules and it's valid
            INSTALL_LOG="/tmp/npm-install-$$.log"
            
            # Clean any partial/corrupted node_modules to prevent ENOTEMPTY errors
            echo "🧹 Checking for stale node_modules..."
            if [ -d node_modules ]; then
              # Check if lockfile changed (need fresh install)
              if [ "$LOCKFILE_HASH" != "$PREV_HASH" ]; then
                echo "⚠️  Lockfile changed, cleaning node_modules to prevent conflicts..."
                rm -rf node_modules
              else
                echo "✓ node_modules exists and lockfile unchanged"
              fi
            fi
            
            # Fast path: use ci if package-lock exists
            if [ -f package-lock.json ]; then
              echo "✓ Using npm ci (fast reproducible install)"
              echo "✓ Skipping Puppeteer/Chromium download"
              echo "✓ Skipping Tesseract download"
              
              # npm ci requires clean state - remove node_modules if exists
              if [ -d node_modules ]; then
                echo "🧹 Removing existing node_modules for clean npm ci..."
                rm -rf node_modules || {
                  echo "⚠️  Failed to remove node_modules, trying with sudo..."
                  sudo rm -rf node_modules || {
                    echo "❌ Cannot remove node_modules even with sudo"
                    exit 1
                  }
                }
              fi
              
              if timeout 180 npm ci --omit=dev --prefer-offline --ignore-scripts 2>&1 | tee "$INSTALL_LOG"; then
                echo "✅ npm ci succeeded"
                echo "$LOCKFILE_HASH" > .lock_hash
              else
                INSTALL_EXIT=$?
                echo ""
                echo "⚠️  npm ci failed with exit code $INSTALL_EXIT"
                echo "Last 50 lines of install log:"
                tail -50 "$INSTALL_LOG" || true
                
                # Try fallback install without ignore-scripts
                echo ""
                echo "Attempting fallback: clean npm install..."
                rm -rf node_modules package-lock.json
                
                # Fix permissions before retry
                echo "🔧 Fixing file permissions..."
                sudo chown -R $(whoami):$(whoami) . 2>/dev/null || true
                
                if timeout 180 npm install --omit=dev --prefer-offline 2>&1 | tee "$INSTALL_LOG"; then
                  echo "✅ npm install fallback succeeded"
                  echo "$LOCKFILE_HASH" > .lock_hash
                else
                  echo ""
                  echo "❌ Both npm ci and npm install failed"
                  echo "Last 100 lines of install log:"
                  tail -100 "$INSTALL_LOG" || true
                  echo ""
                  echo "🔍 Checking node_modules for partial install:"
                  du -sh node_modules 2>/dev/null || echo "node_modules: not found"
                  echo ""
                  echo "🔍 Checking if it's a network issue:"
                  npm config get registry
                  echo ""
                  echo "🔍 Checking file permissions:"
                  ls -la . | head -10
                  rm -f "$INSTALL_LOG"
                  exit 1
                fi
              fi
            else
              echo "Using npm install (no lock file)..."
              if timeout 180 npm install --omit=dev --ignore-scripts 2>&1 | tee "$INSTALL_LOG"; then
                echo "✅ npm install succeeded"
                echo "$LOCKFILE_HASH" > .lock_hash
              else
                echo "❌ npm install failed"
                echo "Last 100 lines of install log:"
                tail -100 "$INSTALL_LOG" || true
                rm -f "$INSTALL_LOG"
                exit 1
              fi
            fi
            rm -f "$INSTALL_LOG"
          fi
          
          # Set env vars
          export NODE_ENV=production \
                 NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
                 NEXTAUTH_URL=https://naukrimili.com \
                 NEXT_PUBLIC_APP_URL=https://naukrimili.com \
                 DATABASE_URL="$DATABASE_URL" \
                 NEXT_TELEMETRY_DISABLED=1 \
                 GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
                 GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET" \
                 OPENAI_API_KEY="$OPENAI_API_KEY" \
                 GEMINI_API_KEY="$GEMINI_API_KEY" \
                 GROQ_API_KEY="$GROQ_API_KEY" \
                 GOOGLE_CLOUD_OCR_API_KEY="$GOOGLE_CLOUD_OCR_API_KEY"
          
          # Migrations (skip if unchanged)
          if [ -f prisma/schema.prisma ]; then
            SCHEMA_HASH=$(md5sum prisma/schema.prisma 2>/dev/null | cut -d' ' -f1)
            if [ "$SCHEMA_HASH" != "$(cat .prisma_hash 2>/dev/null)" ]; then
              echo "🗄️  Running migrations..."
              timeout 45 npx prisma migrate deploy 2>&1 | tail -3 || echo "⚠️  Migration skipped or failed"
              echo "$SCHEMA_HASH" > .prisma_hash
            else
              echo "⏭️  Schema unchanged"
            fi
          fi
          
          # Restart PM2
          echo "🔄 Restarting application..."
          pm2 delete jobportal 2>/dev/null || true
          pm2 start ecosystem.config.cjs --env production || {
            echo "❌ PM2 start failed"
            pm2 logs jobportal --lines 50 || true
            exit 1
          }
          sleep 2
          pm2 save --force >/dev/null 2>&1
          
          # Health check
          echo "🧪 Checking application health..."
          sleep 3
          if curl -f -s http://localhost:3000/api/health >/dev/null 2>&1; then
            echo "✅ Application is healthy"
          else
            echo "⚠️  Health check may have failed (this is sometimes expected)"
            pm2 logs jobportal --lines 10 || true
          fi
          
          END_TIME=$(date +%s)
          DURATION=$(expr $END_TIME - $START_TIME)
          echo "✅ Deployed in ${DURATION}s"
          exit 0
          DEPLOY_SCRIPT
          
          # Now execute via SSH with env vars properly passed
          echo "🚀 Executing deployment on remote server $FINAL_HOST..."
          
          # Define SSH options with keepalive to prevent connection drops
          SSH_OPTS="-i ~/.ssh/deploy_key -p $FINAL_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 -o BatchMode=yes -o PreferredAuthentications=publickey -vv"
          
          if ssh $SSH_OPTS \
            "$FINAL_USER@$FINAL_HOST" \
            "export NEXTAUTH_SECRET=\"$NEXTAUTH_SECRET\" && \
             export DATABASE_URL=\"$DATABASE_URL\" && \
             export GOOGLE_CLIENT_ID=\"$GOOGLE_CLIENT_ID\" && \
             export GOOGLE_CLIENT_SECRET=\"$GOOGLE_CLIENT_SECRET\" && \
             export OPENAI_API_KEY=\"$OPENAI_API_KEY\" && \
             export GEMINI_API_KEY=\"$GEMINI_API_KEY\" && \
             export GROQ_API_KEY=\"$GROQ_API_KEY\" && \
             export GOOGLE_CLOUD_OCR_API_KEY=\"$GOOGLE_CLOUD_OCR_API_KEY\" && \
             bash -s" < /tmp/deploy_script.sh; then
            echo "✅ Deployment script executed successfully"
          else
            DEPLOY_EXIT=$?
            echo ""
            echo "❌ Remote deployment failed with exit code $DEPLOY_EXIT"
            echo "This may be due to:"
            echo "  - Application startup issues (check PM2 logs on server)"
            echo "  - Database migration failures (check Prisma schema)"
            echo "  - Missing environment variables"
            exit 1
          fi
