name: Deploy to Production (Zero-Downtime)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  HOST: ${{ secrets.HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
  GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
  PROD_URL: https://naukrimili.com
  DEPLOY_FOLDER: /var/www/naukrimili
  STAGING_FOLDER: /var/www/naukrimili-staging
  BACKUP_FOLDER: /var/www/naukrimili-backup

jobs:
  validate_secrets:
    name: "ğŸ” Validate Secrets"
    runs-on: ubuntu-latest
    steps:
      - name: Validate All Required Secrets
        run: |
          set +e
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” VALIDATING ALL PRODUCTION SECRETS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          MISSING=0
          
          # Check critical deployment secrets
          [ -z "$HOST" ] && echo "âŒ HOST: MISSING" && MISSING=1 || echo "âœ… HOST: SET (${#HOST} chars)"
          [ -z "$SSH_USER" ] && echo "âŒ SSH_USER: MISSING" && MISSING=1 || echo "âœ… SSH_USER: SET"
          [ -z "$SSH_PORT" ] && echo "âŒ SSH_PORT: MISSING" && MISSING=1 || echo "âœ… SSH_PORT: SET"
          [ -z "$SSH_KEY" ] && echo "âŒ SSH_KEY: MISSING" && MISSING=1 || echo "âœ… SSH_KEY: SET (${#SSH_KEY} chars)"
          [ -z "$NEXTAUTH_SECRET" ] && echo "âŒ NEXTAUTH_SECRET: MISSING" && MISSING=1 || {
            if [ ${#NEXTAUTH_SECRET} -lt 32 ]; then
              echo "âŒ NEXTAUTH_SECRET: TOO SHORT (${#NEXTAUTH_SECRET} < 32 chars)"
              MISSING=1
            else
              echo "âœ… NEXTAUTH_SECRET: SET (${#NEXTAUTH_SECRET} chars)"
            fi
          }
          [ -z "$DATABASE_URL" ] && echo "âŒ DATABASE_URL: MISSING" && MISSING=1 || echo "âœ… DATABASE_URL: SET"
          
          # Check optional keys (AI APIs - not required for deployment)
          [ -z "$OPENAI_API_KEY" ] && echo "âš ï¸  OPENAI_API_KEY: NOT SET (optional)" || echo "âœ… OPENAI_API_KEY: SET"
          [ -z "$GEMINI_API_KEY" ] && echo "âš ï¸  GEMINI_API_KEY: NOT SET (optional)" || echo "âœ… GEMINI_API_KEY: SET"
          
          echo ""
          if [ $MISSING -eq 1 ]; then
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âŒ DEPLOYMENT BLOCKED: Missing secrets!"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“‹ SETUP INSTRUCTIONS:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Add these secrets:"
            echo ""
            echo "   HOST = srv1054971.hstgr.cloud"
            echo "   SSH_USER = root"
            echo "   SSH_PORT = 22"
            echo "   SSH_KEY = (paste complete private key)"
            echo "   NEXTAUTH_SECRET = (32+ random characters)"
            echo "   DATABASE_URL = postgresql://user:pass@host:5432/db"
            echo ""
            echo "   Note: Google OAuth has been removed. Using manual authentication only."
            echo ""
            exit 1
          fi
          
          echo "âœ… ALL SECRETS VALIDATED"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  build:
    name: "ğŸ”¨ Build Application"
    runs-on: ubuntu-latest
    needs: validate_secrets
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Verify and fix package-lock.json
        run: |
          # Check if package-lock.json exists
          if [ ! -f package-lock.json ]; then
            echo "âš ï¸  package-lock.json not found, generating it..."
            npm install --package-lock-only --legacy-peer-deps || {
              echo "âŒ Failed to generate package-lock.json"
              exit 1
            }
            echo "âœ… package-lock.json generated"
          else
            # Check for Prisma version mismatch
            echo "ğŸ” Checking for Prisma version mismatches..."
            PACKAGE_JSON_PRISMA=$(grep -o '"@prisma/client": "[^"]*"' package.json | cut -d'"' -f4)
            PACKAGE_JSON_PRISMA_CLI=$(grep -o '"prisma": "[^"]*"' package.json | cut -d'"' -f4)
            LOCK_PRISMA=$(grep -o '"@prisma/client": "[^"]*"' package-lock.json | head -1 | cut -d'"' -f4)
            LOCK_PRISMA_CLI=$(grep -o '"prisma": "[^"]*"' package-lock.json | head -1 | cut -d'"' -f4)
            
            echo "   package.json: @prisma/client=$PACKAGE_JSON_PRISMA, prisma=$PACKAGE_JSON_PRISMA_CLI"
            echo "   package-lock.json: @prisma/client=$LOCK_PRISMA, prisma=$LOCK_PRISMA_CLI"
            
            # Check if versions don't match (allowing for ^ prefix)
            MISMATCH=0
            if [ -n "$PACKAGE_JSON_PRISMA" ] && [ -n "$LOCK_PRISMA" ]; then
              # Remove ^ prefix for comparison
              PKG_VERSION=$(echo "$PACKAGE_JSON_PRISMA" | sed 's/^[^0-9]*//')
              LOCK_VERSION=$(echo "$LOCK_PRISMA" | sed 's/^[^0-9]*//')
              if [ "$PKG_VERSION" != "$LOCK_VERSION" ]; then
                echo "   âŒ @prisma/client version mismatch: package.json=$PKG_VERSION, lock=$LOCK_VERSION"
                MISMATCH=1
              fi
            fi
            
            if [ -n "$PACKAGE_JSON_PRISMA_CLI" ] && [ -n "$LOCK_PRISMA_CLI" ]; then
              PKG_CLI_VERSION=$(echo "$PACKAGE_JSON_PRISMA_CLI" | sed 's/^[^0-9]*//')
              LOCK_CLI_VERSION=$(echo "$LOCK_PRISMA_CLI" | sed 's/^[^0-9]*//')
              if [ "$PKG_CLI_VERSION" != "$LOCK_CLI_VERSION" ]; then
                echo "   âŒ prisma CLI version mismatch: package.json=$PKG_CLI_VERSION, lock=$LOCK_CLI_VERSION"
                MISMATCH=1
              fi
            fi
            
            if [ $MISMATCH -eq 1 ]; then
              echo "âš ï¸  Version mismatch detected! Regenerating package-lock.json..."
              rm -f package-lock.json
              # Install Prisma 6.18.0 first to ensure it's in the lock file
              npm install prisma@6.18.0 @prisma/client@6.18.0 --save-dev --save --legacy-peer-deps --package-lock-only || {
                echo "âŒ Failed to regenerate package-lock.json with Prisma 6.18.0"
                exit 1
              }
              echo "âœ… package-lock.json regenerated with Prisma 6.18.0"
            else
              echo "âœ… package-lock.json versions match package.json"
            fi
          fi

      - name: Install dependencies
        env:
          SKIP_POSTINSTALL: true
        run: |
          npm config set registry https://registry.npmjs.org/
          npm config set progress false
          npm config set audit false
          npm config set fund false
          echo "ğŸ“¦ Installing production dependencies..."
          # Try npm ci first (faster, more reliable if lock file is good)
          npm ci --omit=dev --legacy-peer-deps --ignore-scripts 2>&1 | tee npm-install.log || {
            echo "âš ï¸  npm ci failed, checking error..."
            if grep -q "package-lock.json" npm-install.log; then
              echo "ğŸ“ Lock file issue detected, regenerating..."
              rm -f package-lock.json
              npm install --package-lock-only --legacy-peer-deps
              npm ci --omit=dev --legacy-peer-deps --ignore-scripts || {
                echo "âŒ npm ci failed after lock file regeneration"
                cat npm-install.log
                exit 1
              }
            else
              echo "âŒ npm ci failed with unknown error:"
              cat npm-install.log
              exit 1
            fi
          }
          [ -d node_modules ] || { echo "âŒ node_modules not created"; exit 1; }
          echo "âœ… Production dependencies installed"
          
      - name: Verify dotenv is installed
        run: |
          echo "ğŸ” Verifying dotenv is installed..."
          if [ ! -d "node_modules/dotenv" ]; then
            echo "âš ï¸  dotenv not found, installing..."
            npm install dotenv@16.4.5 --save --legacy-peer-deps --no-save || {
              echo "âŒ Failed to install dotenv"
              exit 1
            }
          fi
          [ -d "node_modules/dotenv" ] || { echo "âŒ dotenv still not found after install"; exit 1; }
          echo "âœ… dotenv verified/installed"

      - name: Force install Prisma 6.18.0 (remove any 7.x versions)
        run: |
          echo "ğŸ“¦ Forcing Prisma 6.18.0 installation..."
          
          # Remove any existing Prisma 7.x installations
          echo "ğŸ§¹ Removing any Prisma 7.x installations..."
          npm uninstall prisma @prisma/client @prisma/client-runtime-utils --legacy-peer-deps 2>/dev/null || true
          rm -rf node_modules/.prisma node_modules/@prisma node_modules/.bin/prisma 2>/dev/null || true
          
          # Install Prisma 6.18.0 explicitly
          echo "ğŸ“¦ Installing Prisma 6.18.0 (CLI and Client)..."
          npm install prisma@6.18.0 @prisma/client@6.18.0 --save-dev --save --legacy-peer-deps --no-save --force || {
            echo "âŒ Failed to install Prisma 6.18.0"
            exit 1
          }
          
          # Verify installation
          [ -f node_modules/.bin/prisma ] || { echo "âŒ Prisma binary not found"; exit 1; }
          [ -d node_modules/@prisma/client ] || { echo "âŒ @prisma/client not found"; exit 1; }
          
          # Verify versions are 6.18.0
          PRISMA_VERSION=$(./node_modules/.bin/prisma --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          CLIENT_VERSION=$(npm list @prisma/client --depth=0 2>/dev/null | grep "@prisma/client" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          
          echo "   Prisma CLI version: $PRISMA_VERSION"
          echo "   @prisma/client version: $CLIENT_VERSION"
          
          # Ensure both are exactly 6.18.0 (or at least 6.x)
          if [ -z "$PRISMA_VERSION" ] || [ -z "$CLIENT_VERSION" ]; then
            echo "âŒ Could not determine Prisma versions"
            exit 1
          fi
          
          if echo "$PRISMA_VERSION" | grep -qE "^7\." || echo "$CLIENT_VERSION" | grep -qE "^7\."; then
            echo "âŒ Wrong Prisma version! Expected 6.x, got 7.x"
            echo "   CLI: $PRISMA_VERSION"
            echo "   Client: $CLIENT_VERSION"
            exit 1
          fi
          
          if ! echo "$PRISMA_VERSION" | grep -qE "^6\." || ! echo "$CLIENT_VERSION" | grep -qE "^6\."; then
            echo "âŒ Unexpected Prisma version! Expected 6.x"
            echo "   CLI: $PRISMA_VERSION"
            echo "   Client: $CLIENT_VERSION"
            exit 1
          fi
          
          echo "âœ… Prisma 6.18.0 installed and verified"

      - name: Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
          SKIP_POSTINSTALL: true
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
        run: |
          echo "ğŸ”§ Generating Prisma Client..."
          [ -f prisma/schema.prisma ] || { echo "âŒ schema.prisma not found"; exit 1; }
          
          # Verify Prisma version one more time before generation
          PRISMA_VERSION=$(./node_modules/.bin/prisma --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          echo "   Using Prisma version: $PRISMA_VERSION"
          
          if echo "$PRISMA_VERSION" | grep -qE "^7\."; then
            echo "âŒ ERROR: Prisma 7.x detected! This version doesn't support url in schema.prisma"
            echo "   Please ensure Prisma 6.18.0 is installed"
            exit 1
          fi
          
          if ! echo "$PRISMA_VERSION" | grep -qE "^6\."; then
            echo "âŒ ERROR: Unexpected Prisma version: $PRISMA_VERSION"
            echo "   Expected Prisma 6.x"
            exit 1
          fi
          
          # Clean any previous generation
          rm -rf node_modules/.prisma 2>/dev/null || true
          
          # Generate Prisma client using local binary
          echo "ğŸ“ Generating Prisma client with Prisma 6.18.0..."
          ./node_modules/.bin/prisma generate --schema=prisma/schema.prisma || {
            echo "âš ï¸  Local prisma failed, trying npx with explicit version..."
            npx prisma@6.18.0 generate --schema=prisma/schema.prisma || {
              echo "âŒ Prisma generate failed"
              echo "   Error details above"
              exit 1
            }
          }
          
          # Verify client was generated
          [ -d node_modules/.prisma/client ] || [ -d node_modules/@prisma/client ] || \
            { echo "âŒ Prisma client not generated"; exit 1; }
          
          echo "âœ… Prisma client generated successfully with Prisma 6.18.0"

      - name: Build Next.js
        timeout-minutes: 12
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ env.PROD_URL }}
          NEXT_PUBLIC_APP_URL: ${{ env.PROD_URL }}
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          NODE_OPTIONS: --max-old-space-size=6144
          ESLINT_NO_DEV_ERRORS: true
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
        run: |
          echo "ğŸ”¨ Building Next.js..."
          npm run build 2>&1 | tail -30 || {
            echo "âš ï¸  npm run build failed, trying npx next build..."
            npx next build 2>&1 | tail -30 || { echo "âŒ Build failed"; exit 1; }
          }
          
          [ -d .next ] || { echo "âŒ .next not created"; exit 1; }
          FILE_COUNT=$(find .next -type f 2>/dev/null | wc -l)
          [ "$FILE_COUNT" -gt 50 ] || { echo "âŒ .next appears empty ($FILE_COUNT files)"; exit 1; }
          echo "âœ… Build successful ($FILE_COUNT files)"

      - name: Create deployment bundle
        run: |
          echo "ğŸ“¦ Creating bundle..."
          BUNDLE_DIR="/tmp/deploy-$$"
          mkdir -p "$BUNDLE_DIR"
          
          # Copy all files to bundle directory first (static snapshot)
          echo "ğŸ“¦ Copying files to bundle directory..."
          cp -r .next "$BUNDLE_DIR/" || { echo "âŒ Failed to copy .next"; exit 1; }
          find "$BUNDLE_DIR/.next" -name "*.map" -delete
          [ -f package.json ] && cp package.json "$BUNDLE_DIR/"
          [ -f package-lock.json ] && cp package-lock.json "$BUNDLE_DIR/"
          [ -f ecosystem.config.cjs ] && cp ecosystem.config.cjs "$BUNDLE_DIR/"
          [ -f next.config.mjs ] && cp next.config.mjs "$BUNDLE_DIR/"
          [ -d public ] && cp -r public "$BUNDLE_DIR/"
          [ -d prisma ] && cp -r prisma "$BUNDLE_DIR/"
          
          # Wait a moment to ensure all file operations are complete
          sleep 1
          
          # Create tar archive from the static bundle directory
          # Use -C to change directory before archiving to avoid "file changed" errors
          echo "ğŸ“¦ Creating archive from static bundle directory..."
          tar -czf release.tar.gz -C "$BUNDLE_DIR" . || { 
            echo "âŒ tar failed"
            echo "   Bundle directory contents:"
            ls -la "$BUNDLE_DIR" || true
            exit 1
          }
          
          # Move archive to current directory
          mv "$BUNDLE_DIR/release.tar.gz" . || { echo "âŒ mv failed"; exit 1; }
          
          # Clean up bundle directory
          rm -rf "$BUNDLE_DIR"
          
          [ -f release.tar.gz ] || { echo "âŒ release.tar.gz not created"; exit 1; }
          SIZE=$(du -h release.tar.gz | cut -f1)
          echo "âœ… Bundle created: $SIZE"

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-bundle
          path: release.tar.gz
          retention-days: 1

  deploy:
    name: "ğŸš€ Deploy to Production (Zero-Downtime)"
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download bundle
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Handle both escaped and unescaped newlines
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key  # Remove CRLF
          chmod 600 ~/.ssh/deploy_key
          
          # Validate SSH key
          grep -q "BEGIN.*PRIVATE" ~/.ssh/deploy_key || { echo "âŒ Invalid SSH key"; exit 1; }
          grep -q "END.*PRIVATE" ~/.ssh/deploy_key || { echo "âŒ SSH key missing END marker"; exit 1; }
          echo "âœ… SSH key valid ($(wc -c < ~/.ssh/deploy_key) bytes)"

      - name: Test SSH connection
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "echo 'âœ… SSH OK' && uname -a" || {
            echo "âŒ SSH failed - check SSH_KEY, HOST, SSH_PORT, SSH_USER"
            exit 1
          }

      - name: Upload bundle to staging
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          # Create folders
          ssh $SSH_OPTS "$SSH_USER@$HOST" "mkdir -p $DEPLOY_FOLDER $STAGING_FOLDER $BACKUP_FOLDER"
          
          # Upload
          TIMESTAMP=$(date +%s)
          BUNDLE_NAME="release-$TIMESTAMP.tar.gz"
          rsync -avz -e "ssh $SSH_OPTS" release.tar.gz "$SSH_USER@$HOST:$STAGING_FOLDER/$BUNDLE_NAME" || {
            echo "âŒ rsync failed"
            exit 1
          }
          echo "âœ… Bundle uploaded to $STAGING_FOLDER/$BUNDLE_NAME"
          
          # Save bundle name for deploy step
          echo "$BUNDLE_NAME" > bundle_name.txt

      - name: Save bundle name
        uses: actions/upload-artifact@v4
        with:
          name: bundle-info
          path: bundle_name.txt
          retention-days: 1

  finalize:
    name: "âœ… Finalize Deployment (Zero-Downtime Swap)"
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Download bundle info
        uses: actions/download-artifact@v4
        with:
          name: bundle-info

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Deploy with zero-downtime swap
        run: |
          set -e
          BUNDLE_NAME=$(cat bundle_name.txt)
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes"
          
          echo "ğŸš€ Deploying $BUNDLE_NAME with zero-downtime swap..."
          
          # Remote deployment script
          ssh $SSH_OPTS "$SSH_USER@$HOST" << 'EOF'
          set -e
          BUNDLE_NAME=$(cat /tmp/bundle_name.txt 2>/dev/null || echo "")
          [ -n "$BUNDLE_NAME" ] || BUNDLE_NAME=$(ls -t $STAGING_FOLDER/*.tar.gz 2>/dev/null | head -1 | xargs basename)
          
          STAGING_PATH="$STAGING_FOLDER/$BUNDLE_NAME"
          TEMP_DEPLOY="/var/www/naukrimili-temp-$$"
          PROD_DEPLOY="$DEPLOY_FOLDER"
          BACKUP_PATH="$BACKUP_FOLDER/backup-$(date +%s)"
          
          echo "ğŸ“¦ Bundle: $BUNDLE_NAME"
          echo "ğŸ“‚ Temp folder: $TEMP_DEPLOY"
          
          # Extract to temp folder
          mkdir -p "$TEMP_DEPLOY"
          cd "$TEMP_DEPLOY"
          tar -xzf "$STAGING_PATH" || { echo "âŒ Extract failed"; exit 1; }
          echo "âœ… Bundle extracted"
          
          # Install dependencies
          if [ -f package-lock.json ]; then
            echo "ğŸ“š Installing dependencies..."
            npm ci --omit=dev --prefer-offline 2>&1 | tail -5 || echo "âš ï¸  npm ci had issues"
          fi
          
          # Run migrations if schema changed
          if [ -f prisma/schema.prisma ]; then
            export NODE_ENV=production
            export DATABASE_URL="$DATABASE_URL"
            echo "ğŸ—„ï¸  Running migrations..."
            timeout 60 npx prisma migrate deploy 2>&1 | tail -5 || echo "âš ï¸  Migration warning"
          fi
          
          # Start PM2 in temp folder to test
          echo "ğŸ§ª Testing application in temp folder..."
          pm2 delete jobportal-test 2>/dev/null || true
          if pm2 start ecosystem.config.cjs --name jobportal-test --env production; then
            sleep 3
            
            # Health check
            if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "âœ… Health check passed"
              
              # Success: backup current and swap
              echo "ğŸ”„ Swapping to production..."
              pm2 delete jobportal-test 2>/dev/null || true
              
              if [ -d "$PROD_DEPLOY/.next" ]; then
                echo "ğŸ’¾ Backing up current version..."
                mkdir -p "$BACKUP_PATH"
                cp -r "$PROD_DEPLOY/.next" "$BACKUP_PATH/" || true
                cp -r "$PROD_DEPLOY/node_modules" "$BACKUP_PATH/" 2>/dev/null || true
              fi
              
              # Atomic swap
              rm -rf "$PROD_DEPLOY.old"
              [ -d "$PROD_DEPLOY" ] && mv "$PROD_DEPLOY" "$PROD_DEPLOY.old" || true
              mv "$TEMP_DEPLOY" "$PROD_DEPLOY"
              rm -rf "$PROD_DEPLOY.old" "$TEMP_DEPLOY"
              
              # Start production PM2
              cd "$PROD_DEPLOY"
              pm2 delete jobportal 2>/dev/null || true
              pm2 start ecosystem.config.cjs --env production || {
                echo "âŒ PM2 failed, rolling back..."
                [ -d "$BACKUP_PATH/.next" ] && {
                  cp -r "$BACKUP_PATH/.next" "$PROD_DEPLOY/"
                  pm2 start ecosystem.config.cjs --env production
                }
                exit 1
              }
              pm2 save --force
              sleep 2
              
              # Final health check
              if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
                echo "âœ… Production deployment successful"
                # Clean old backups (keep last 3)
                cd "$BACKUP_FOLDER"
                ls -t | tail -n +4 | xargs -r rm -rf
                rm -f "$STAGING_PATH"
              else
                echo "âŒ Production health check failed"
                exit 1
              fi
            else
              echo "âŒ Health check failed in temp folder"
              pm2 logs jobportal-test --lines 20 || true
              rm -rf "$TEMP_DEPLOY"
              exit 1
            fi
          else
            echo "âŒ Failed to start PM2 in temp folder"
            pm2 logs jobportal-test --lines 50 || true
            rm -rf "$TEMP_DEPLOY"
            exit 1
          fi
          EOF
          
          echo "âœ… Deployment complete - zero downtime achieved!"

      - name: Post-deployment verification
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15"
          
          echo "ğŸ§ª Running post-deployment checks..."
          
          # Check PM2 status
          echo ""
          echo "ğŸ“Š PM2 Status:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "pm2 status" || echo "âš ï¸  Could not get PM2 status"
          
          # Check health endpoint
          echo ""
          echo "ğŸ¥ Health Check:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "curl -s http://localhost:3000/api/health | head -c 200 || echo 'âš ï¸  No response'" || true
          
          # Check disk usage
          echo ""
          echo "ğŸ’¾ Disk Usage:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "du -sh $DEPLOY_FOLDER $BACKUP_FOLDER 2>/dev/null || echo 'N/A'" || true
          
          echo ""
          echo "âœ… Post-deployment verification complete"
