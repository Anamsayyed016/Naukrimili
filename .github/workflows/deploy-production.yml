name: Deploy to Production (Zero-Downtime)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  HOST: ${{ secrets.HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
  GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
  PROD_URL: https://naukrimili.com
  DEPLOY_FOLDER: /var/www/naukrimili
  STAGING_FOLDER: /var/www/naukrimili-staging
  BACKUP_FOLDER: /var/www/naukrimili-backup

jobs:
  validate_secrets:
    name: "๐ Validate Secrets"
    runs-on: ubuntu-latest
    steps:
      - name: Validate All Required Secrets
        run: |
          set +e
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo "๐ VALIDATING ALL PRODUCTION SECRETS"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo ""
          
          MISSING=0
          
          # Check critical deployment secrets
          [ -z "$HOST" ] && echo "โ HOST: MISSING" && MISSING=1 || echo "โ HOST: SET (${#HOST} chars)"
          [ -z "$SSH_USER" ] && echo "โ SSH_USER: MISSING" && MISSING=1 || echo "โ SSH_USER: SET"
          [ -z "$SSH_PORT" ] && echo "โ SSH_PORT: MISSING" && MISSING=1 || echo "โ SSH_PORT: SET"
          [ -z "$SSH_KEY" ] && echo "โ SSH_KEY: MISSING" && MISSING=1 || echo "โ SSH_KEY: SET (${#SSH_KEY} chars)"
          [ -z "$NEXTAUTH_SECRET" ] && echo "โ NEXTAUTH_SECRET: MISSING" && MISSING=1 || {
            if [ ${#NEXTAUTH_SECRET} -lt 32 ]; then
              echo "โ NEXTAUTH_SECRET: TOO SHORT (${#NEXTAUTH_SECRET} < 32 chars)"
              MISSING=1
            else
              echo "โ NEXTAUTH_SECRET: SET (${#NEXTAUTH_SECRET} chars)"
            fi
          }
          [ -z "$DATABASE_URL" ] && echo "โ DATABASE_URL: MISSING" && MISSING=1 || echo "โ DATABASE_URL: SET"
          
          # Check optional keys (AI APIs - not required for deployment)
          [ -z "$OPENAI_API_KEY" ] && echo "โ๏ธ  OPENAI_API_KEY: NOT SET (optional)" || echo "โ OPENAI_API_KEY: SET"
          [ -z "$GEMINI_API_KEY" ] && echo "โ๏ธ  GEMINI_API_KEY: NOT SET (optional)" || echo "โ GEMINI_API_KEY: SET"
          
          echo ""
          if [ $MISSING -eq 1 ]; then
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "โ DEPLOYMENT BLOCKED: Missing secrets!"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo ""
            echo "๐ SETUP INSTRUCTIONS:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Add these secrets:"
            echo ""
            echo "   HOST = srv1054971.hstgr.cloud"
            echo "   SSH_USER = root"
            echo "   SSH_PORT = 22"
            echo "   SSH_KEY = (paste complete private key)"
            echo "   NEXTAUTH_SECRET = (32+ random characters)"
            echo "   DATABASE_URL = postgresql://user:pass@host:5432/db"
            echo ""
            echo "   Note: Google OAuth has been removed. Using manual authentication only."
            echo ""
            exit 1
          fi
          
          echo "โ ALL SECRETS VALIDATED"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"

  build:
    name: "๐จ Build Application"
    runs-on: ubuntu-latest
    needs: validate_secrets
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Verify and fix package-lock.json
        run: |
          # Check if package-lock.json exists
          if [ ! -f package-lock.json ]; then
            echo "โ๏ธ  package-lock.json not found, generating it..."
            npm install --package-lock-only --legacy-peer-deps || {
              echo "โ Failed to generate package-lock.json"
              exit 1
            }
            echo "โ package-lock.json generated"
          else
            # Check for Prisma version mismatch
            echo "๐ Checking for Prisma version mismatches..."
            PACKAGE_JSON_PRISMA=$(grep -o '"@prisma/client": "[^"]*"' package.json | cut -d'"' -f4)
            PACKAGE_JSON_PRISMA_CLI=$(grep -o '"prisma": "[^"]*"' package.json | cut -d'"' -f4)
            LOCK_PRISMA=$(grep -o '"@prisma/client": "[^"]*"' package-lock.json | head -1 | cut -d'"' -f4)
            LOCK_PRISMA_CLI=$(grep -o '"prisma": "[^"]*"' package-lock.json | head -1 | cut -d'"' -f4)
            
            echo "   package.json: @prisma/client=$PACKAGE_JSON_PRISMA, prisma=$PACKAGE_JSON_PRISMA_CLI"
            echo "   package-lock.json: @prisma/client=$LOCK_PRISMA, prisma=$LOCK_PRISMA_CLI"
            
            # Check if versions don't match (allowing for ^ prefix)
            MISMATCH=0
            if [ -n "$PACKAGE_JSON_PRISMA" ] && [ -n "$LOCK_PRISMA" ]; then
              # Remove ^ prefix for comparison
              PKG_VERSION=$(echo "$PACKAGE_JSON_PRISMA" | sed 's/^[^0-9]*//')
              LOCK_VERSION=$(echo "$LOCK_PRISMA" | sed 's/^[^0-9]*//')
              if [ "$PKG_VERSION" != "$LOCK_VERSION" ]; then
                echo "   โ @prisma/client version mismatch: package.json=$PKG_VERSION, lock=$LOCK_VERSION"
                MISMATCH=1
              fi
            fi
            
            if [ -n "$PACKAGE_JSON_PRISMA_CLI" ] && [ -n "$LOCK_PRISMA_CLI" ]; then
              PKG_CLI_VERSION=$(echo "$PACKAGE_JSON_PRISMA_CLI" | sed 's/^[^0-9]*//')
              LOCK_CLI_VERSION=$(echo "$LOCK_PRISMA_CLI" | sed 's/^[^0-9]*//')
              if [ "$PKG_CLI_VERSION" != "$LOCK_CLI_VERSION" ]; then
                echo "   โ prisma CLI version mismatch: package.json=$PKG_CLI_VERSION, lock=$LOCK_CLI_VERSION"
                MISMATCH=1
              fi
            fi
            
            if [ $MISMATCH -eq 1 ]; then
              echo "โ๏ธ  Version mismatch detected! Regenerating package-lock.json..."
              rm -f package-lock.json
              # Install Prisma 6.18.0 first to ensure it's in the lock file
              npm install prisma@6.18.0 @prisma/client@6.18.0 --save-dev --save --legacy-peer-deps --package-lock-only || {
                echo "โ Failed to regenerate package-lock.json with Prisma 6.18.0"
                exit 1
              }
              echo "โ package-lock.json regenerated with Prisma 6.18.0"
            else
              echo "โ package-lock.json versions match package.json"
            fi
          fi

      - name: Install dependencies
        env:
          SKIP_POSTINSTALL: true
        run: |
          npm config set registry https://registry.npmjs.org/
          npm config set progress false
          npm config set audit false
          npm config set fund false
          echo "๐ฆ Installing production dependencies..."
          # Try npm ci first (faster, more reliable if lock file is good)
          npm ci --omit=dev --legacy-peer-deps --ignore-scripts 2>&1 | tee npm-install.log || {
            echo "โ๏ธ  npm ci failed, checking error..."
            if grep -q "package-lock.json" npm-install.log; then
              echo "๐ Lock file issue detected, regenerating..."
              rm -f package-lock.json
              npm install --package-lock-only --legacy-peer-deps
              npm ci --omit=dev --legacy-peer-deps --ignore-scripts || {
                echo "โ npm ci failed after lock file regeneration"
                cat npm-install.log
                exit 1
              }
            else
              echo "โ npm ci failed with unknown error:"
              cat npm-install.log
              exit 1
            fi
          }
          [ -d node_modules ] || { echo "โ node_modules not created"; exit 1; }
          echo "โ Production dependencies installed"
          
      - name: Verify dotenv is installed
        run: |
          echo "๐ Verifying dotenv is installed..."
          if [ ! -d "node_modules/dotenv" ]; then
            echo "โ๏ธ  dotenv not found, installing..."
            npm install dotenv@16.4.5 --save --legacy-peer-deps --no-save || {
              echo "โ Failed to install dotenv"
              exit 1
            }
          fi
          [ -d "node_modules/dotenv" ] || { echo "โ dotenv still not found after install"; exit 1; }
          echo "โ dotenv verified/installed"

      - name: Force install Prisma 6.18.0 (remove any 7.x versions)
        run: |
          echo "๐ฆ Forcing Prisma 6.18.0 installation..."
          
          # Remove any existing Prisma 7.x installations
          echo "๐งน Removing any Prisma 7.x installations..."
          npm uninstall prisma @prisma/client @prisma/client-runtime-utils --legacy-peer-deps 2>/dev/null || true
          rm -rf node_modules/.prisma node_modules/@prisma node_modules/.bin/prisma 2>/dev/null || true
          
          # Install Prisma 6.18.0 explicitly
          echo "๐ฆ Installing Prisma 6.18.0 (CLI and Client)..."
          npm install prisma@6.18.0 @prisma/client@6.18.0 --save-dev --save --legacy-peer-deps --no-save --force || {
            echo "โ Failed to install Prisma 6.18.0"
            exit 1
          }
          
          # Verify installation
          [ -f node_modules/.bin/prisma ] || { echo "โ Prisma binary not found"; exit 1; }
          [ -d node_modules/@prisma/client ] || { echo "โ @prisma/client not found"; exit 1; }
          
          # Verify versions are 6.18.0
          PRISMA_VERSION=$(./node_modules/.bin/prisma --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          CLIENT_VERSION=$(npm list @prisma/client --depth=0 2>/dev/null | grep "@prisma/client" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          
          echo "   Prisma CLI version: $PRISMA_VERSION"
          echo "   @prisma/client version: $CLIENT_VERSION"
          
          # Ensure both are exactly 6.18.0 (or at least 6.x)
          if [ -z "$PRISMA_VERSION" ] || [ -z "$CLIENT_VERSION" ]; then
            echo "โ Could not determine Prisma versions"
            exit 1
          fi
          
          if echo "$PRISMA_VERSION" | grep -qE "^7\." || echo "$CLIENT_VERSION" | grep -qE "^7\."; then
            echo "โ Wrong Prisma version! Expected 6.x, got 7.x"
            echo "   CLI: $PRISMA_VERSION"
            echo "   Client: $CLIENT_VERSION"
            exit 1
          fi
          
          if ! echo "$PRISMA_VERSION" | grep -qE "^6\." || ! echo "$CLIENT_VERSION" | grep -qE "^6\."; then
            echo "โ Unexpected Prisma version! Expected 6.x"
            echo "   CLI: $PRISMA_VERSION"
            echo "   Client: $CLIENT_VERSION"
            exit 1
          fi
          
          echo "โ Prisma 6.18.0 installed and verified"

      - name: Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
          SKIP_POSTINSTALL: true
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
        run: |
          echo "๐ง Generating Prisma Client..."
          [ -f prisma/schema.prisma ] || { echo "โ schema.prisma not found"; exit 1; }
          
          # Verify Prisma version one more time before generation
          PRISMA_VERSION=$(./node_modules/.bin/prisma --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
          echo "   Using Prisma version: $PRISMA_VERSION"
          
          if echo "$PRISMA_VERSION" | grep -qE "^7\."; then
            echo "โ ERROR: Prisma 7.x detected! This version doesn't support url in schema.prisma"
            echo "   Please ensure Prisma 6.18.0 is installed"
            exit 1
          fi
          
          if ! echo "$PRISMA_VERSION" | grep -qE "^6\."; then
            echo "โ ERROR: Unexpected Prisma version: $PRISMA_VERSION"
            echo "   Expected Prisma 6.x"
            exit 1
          fi
          
          # Clean any previous generation
          rm -rf node_modules/.prisma 2>/dev/null || true
          
          # Generate Prisma client using local binary
          echo "๐ Generating Prisma client with Prisma 6.18.0..."
          ./node_modules/.bin/prisma generate --schema=prisma/schema.prisma || {
            echo "โ๏ธ  Local prisma failed, trying npx with explicit version..."
            npx prisma@6.18.0 generate --schema=prisma/schema.prisma || {
              echo "โ Prisma generate failed"
              echo "   Error details above"
              exit 1
            }
          }
          
          # Verify client was generated
          [ -d node_modules/.prisma/client ] || [ -d node_modules/@prisma/client ] || \
            { echo "โ Prisma client not generated"; exit 1; }
          
          echo "โ Prisma client generated successfully with Prisma 6.18.0"

      - name: Build Next.js
        timeout-minutes: 12
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ env.PROD_URL }}
          NEXT_PUBLIC_APP_URL: ${{ env.PROD_URL }}
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          NODE_OPTIONS: --max-old-space-size=6144
          ESLINT_NO_DEV_ERRORS: true
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
        run: |
          echo "๐จ Building Next.js..."
          echo "๐ Build environment:"
          echo "   NODE_ENV: $NODE_ENV"
          echo "   DATABASE_URL: ${DATABASE_URL:0:20}..."
          echo "   NEXTAUTH_URL: $NEXTAUTH_URL"
          
          # Build with full output to see all pages being built
          # CRITICAL: Ensure build completes successfully and generates static files
          echo "๐จ Starting Next.js build..."
          BUILD_SUCCESS=false
          
          if npm run build 2>&1 | tee build.log; then
            BUILD_SUCCESS=true
            echo "โ npm run build completed"
          else
            echo "โ๏ธ  npm run build failed, trying npx next build..."
            if npx next build 2>&1 | tee build.log; then
              BUILD_SUCCESS=true
              echo "โ npx next build completed"
            else
              echo "โ Build failed"
              echo "๐ Last 50 lines of build log:"
              tail -50 build.log || true
              echo "๐ Build errors:"
              grep -i "error\|fail" build.log | tail -20 || true
              exit 1
            fi
          fi
          
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "โ Build did not complete successfully"
            exit 1
          fi
          
          # Verify .next directory was created
          [ -d .next ] || { 
            echo "โ .next directory not created after build"
            echo "   Build log errors:"
            grep -i "error\|fail" build.log | tail -20 || true
            exit 1
          }
          
          FILE_COUNT=$(find .next -type f 2>/dev/null | wc -l)
          [ "$FILE_COUNT" -gt 50 ] || { 
            echo "โ .next appears empty ($FILE_COUNT files)"
            echo "   .next directory contents:"
            ls -la .next 2>/dev/null || true
            echo "   Build log errors:"
            grep -i "error\|fail" build.log | tail -20 || true
            exit 1
          }
          
          echo "โ Build successful ($FILE_COUNT files)"
          echo "๐ Checking build output for routes..."
          if [ -f .next/routes-manifest.json ]; then
            echo "   Routes manifest found"
            cat .next/routes-manifest.json | head -20 || true
          fi
          
          # Check if pages are in the build output
          echo "๐ Checking for built pages..."
          if [ -d .next/server/app ]; then
            echo "   Found app directory pages:"
            find .next/server/app -name "page.js" -o -name "page.js.map" 2>/dev/null | head -20 || true
            PAGE_COUNT=$(find .next/server/app -name "page.js" 2>/dev/null | wc -l)
            echo "   Total pages found: $PAGE_COUNT"
            if [ "$PAGE_COUNT" -lt 10 ]; then
              echo "โ๏ธ  WARNING: Very few pages found in build output ($PAGE_COUNT)"
              echo "   This might indicate pages are not being built properly"
            fi
          fi
          
          # CRITICAL: Verify static files are generated
          echo "๐ Checking for static files..."
          if [ -d .next/static ]; then
            STATIC_COUNT=$(find .next/static -type f 2>/dev/null | wc -l)
            echo "   Static files found: $STATIC_COUNT"
            if [ "$STATIC_COUNT" -lt 10 ]; then
              echo "โ CRITICAL: Very few static files found ($STATIC_COUNT)"
              echo "   This will cause CSS/JS 404 errors in production!"
              echo "   Checking build output for errors..."
              echo "   .next/static directory structure:"
              find .next/static -type d 2>/dev/null | head -10 || true
              echo "   .next/static files:"
              find .next/static -type f 2>/dev/null | head -20 || true
              echo "   Build log errors:"
              grep -i "error\|warn\|fail" build.log 2>/dev/null | tail -20 || true
              echo "   Attempting to rebuild static files..."
              # Try to regenerate static files by running next build again with explicit static generation
              NODE_ENV=production npx next build --debug 2>&1 | tail -50 || {
                echo "โ Rebuild failed - static files cannot be generated"
                exit 1
              }
              # Re-check static files after rebuild
              STATIC_COUNT=$(find .next/static -type f 2>/dev/null | wc -l)
              if [ "$STATIC_COUNT" -lt 10 ]; then
                echo "โ CRITICAL: Static files still missing after rebuild ($STATIC_COUNT)"
                exit 1
              fi
            else
              echo "โ Static files generated successfully"
              # Show sample static files
              echo "   Sample static files:"
              find .next/static -type f 2>/dev/null | head -10 || true
            fi
          else
            echo "โ CRITICAL: .next/static directory not found!"
            echo "   This will cause all CSS/JS files to return 404 errors!"
            echo "   .next directory contents:"
            ls -la .next 2>/dev/null || true
            echo "   Build log errors:"
            grep -i "error\|warn\|fail" build.log 2>/dev/null | tail -20 || true
            exit 1
          fi
          
          # Check for standalone build
          if [ -d .next/standalone ]; then
            echo "โ Standalone build found"
            STANDALONE_COUNT=$(find .next/standalone -type f 2>/dev/null | wc -l)
            echo "   Standalone files: $STANDALONE_COUNT"
          else
            echo "โ๏ธ  Standalone build not found (using standard Next.js mode)"
          fi

      - name: Create deployment bundle
        run: |
          echo "๐ฆ Creating bundle..."
          BUNDLE_DIR="/tmp/deploy-$$"
          mkdir -p "$BUNDLE_DIR"
          
          # Copy all files to bundle directory first (static snapshot)
          echo "๐ฆ Copying files to bundle directory..."
          
          # CRITICAL: Verify .next/static exists before copying
          if [ ! -d .next/static ]; then
            echo "โ CRITICAL: .next/static directory not found!"
            echo "   Static files are required for CSS/JS to work in production"
            exit 1
          fi
          
          STATIC_FILE_COUNT=$(find .next/static -type f 2>/dev/null | wc -l)
          echo "   Found $STATIC_FILE_COUNT static files to copy"
          
          cp -r .next "$BUNDLE_DIR/" || { echo "โ Failed to copy .next"; exit 1; }
          
          # Verify static files were copied
          if [ ! -d "$BUNDLE_DIR/.next/static" ]; then
            echo "โ CRITICAL: Static files not copied to bundle!"
            exit 1
          fi
          
          BUNDLE_STATIC_COUNT=$(find "$BUNDLE_DIR/.next/static" -type f 2>/dev/null | wc -l)
          echo "   Copied $BUNDLE_STATIC_COUNT static files to bundle"
          
          if [ "$BUNDLE_STATIC_COUNT" -lt 10 ]; then
            echo "โ๏ธ  WARNING: Very few static files in bundle ($BUNDLE_STATIC_COUNT)"
            echo "   This may cause CSS/JS 404 errors in production"
          fi
          
          # Verify standalone server exists (required for PM2)
          if [ -d "$BUNDLE_DIR/.next/standalone" ]; then
            echo "โ Standalone server found in bundle"
            if [ ! -f "$BUNDLE_DIR/.next/standalone/server.js" ]; then
              echo "โ๏ธ  WARNING: standalone/server.js not found, PM2 may use fallback"
            fi
          else
            echo "โ๏ธ  WARNING: Standalone server not found in bundle"
            echo "   PM2 will use fallback mode (next start or server.cjs)"
          fi
          
          # Delete source maps in a separate step and wait for completion
          echo "๐งน Removing source maps..."
          find "$BUNDLE_DIR/.next" -name "*.map" -type f -delete
          sync  # Force filesystem sync to ensure deletions are complete
          
          # Copy remaining files - CRITICAL: All must be present
          echo "๐ฆ Copying required files to bundle..."
          
          # Verify and copy package.json
          if [ ! -f package.json ]; then
            echo "โ package.json not found!"
            exit 1
          fi
          cp package.json "$BUNDLE_DIR/" || { echo "โ Failed to copy package.json"; exit 1; }
          
          # Verify and copy package-lock.json
          if [ ! -f package-lock.json ]; then
            echo "โ๏ธ  package-lock.json not found (will be regenerated)"
          else
            cp package-lock.json "$BUNDLE_DIR/" || { echo "โ Failed to copy package-lock.json"; exit 1; }
          fi
          
          # CRITICAL: Verify and copy ecosystem.config.cjs
          if [ ! -f ecosystem.config.cjs ]; then
            echo "โ CRITICAL: ecosystem.config.cjs not found!"
            echo "   This file is required for PM2 to start the application"
            exit 1
          fi
          cp ecosystem.config.cjs "$BUNDLE_DIR/" || { echo "โ Failed to copy ecosystem.config.cjs"; exit 1; }
          echo "โ ecosystem.config.cjs copied"
          
          # Verify and copy next.config.mjs
          if [ ! -f next.config.mjs ]; then
            echo "โ๏ธ  next.config.mjs not found"
          else
            cp next.config.mjs "$BUNDLE_DIR/" || { echo "โ Failed to copy next.config.mjs"; exit 1; }
          fi
          
          # Copy public directory if it exists
          if [ -d public ]; then
            cp -r public "$BUNDLE_DIR/" || { echo "โ Failed to copy public directory"; exit 1; }
            echo "โ public directory copied"
          else
            echo "โ๏ธ  public directory not found"
          fi
          
          # Copy prisma directory if it exists
          if [ -d prisma ]; then
            cp -r prisma "$BUNDLE_DIR/" || { echo "โ Failed to copy prisma directory"; exit 1; }
            echo "โ prisma directory copied"
          else
            echo "โ๏ธ  prisma directory not found"
          fi
          
          # Verify all critical files are in bundle
          echo "๐ Verifying critical files in bundle..."
          if [ ! -f "$BUNDLE_DIR/ecosystem.config.cjs" ]; then
            echo "โ CRITICAL: ecosystem.config.cjs not in bundle!"
            exit 1
          fi
          if [ ! -d "$BUNDLE_DIR/.next" ]; then
            echo "โ CRITICAL: .next directory not in bundle!"
            exit 1
          fi
          if [ ! -d "$BUNDLE_DIR/.next/static" ]; then
            echo "โ CRITICAL: .next/static directory not in bundle!"
            exit 1
          fi
          echo "โ All critical files verified in bundle"
          
          # Force filesystem sync to ensure all copy operations are complete
          sync
          
          # Wait to ensure all file operations are fully committed to disk
          sleep 2
          
          # Verify bundle directory exists and has content
          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "โ Bundle directory does not exist: $BUNDLE_DIR"
            exit 1
          fi
          
          if [ -z "$(ls -A "$BUNDLE_DIR" 2>/dev/null)" ]; then
            echo "โ Bundle directory is empty: $BUNDLE_DIR"
            exit 1
          fi
          
          echo "๐ฆ Creating archive from static bundle directory..."
          echo "   Bundle directory: $BUNDLE_DIR"
          echo "   Bundle contents:"
          ls -la "$BUNDLE_DIR" | head -20 || true
          
          # Create tar archive INSIDE the bundle directory
          # CRITICAL: Specify full path for output file to create it in $BUNDLE_DIR
          # Use --warning=no-file-changed to ignore warnings about files changing
          # This is safe because we've already synced all file operations
          echo "๐ฆ Creating tar archive..."
          tar -czf "$BUNDLE_DIR/release.tar.gz" -C "$BUNDLE_DIR" . --warning=no-file-changed 2>&1 || {
            # Check if tar actually failed or just warned
            if [ -f "$BUNDLE_DIR/release.tar.gz" ]; then
              echo "โ๏ธ  tar reported warnings but archive was created successfully"
            else
              echo "โ tar failed - archive was not created"
              echo "   Current directory: $(pwd)"
              echo "   Bundle directory: $BUNDLE_DIR"
              echo "   Bundle directory contents:"
              ls -la "$BUNDLE_DIR" || true
              exit 1
            fi
          }
          
          # Verify archive was created
          if [ ! -f "$BUNDLE_DIR/release.tar.gz" ]; then
            echo "โ Archive was not created at $BUNDLE_DIR/release.tar.gz"
            echo "   Current directory: $(pwd)"
            echo "   Files in current directory:"
            ls -la . | grep -E "release|tar" || true
            echo "   Files in bundle directory:"
            ls -la "$BUNDLE_DIR" | grep -E "release|tar" || true
            exit 1
          fi
          
          # Move archive to current directory
          echo "๐ฆ Moving archive to current directory..."
          mv "$BUNDLE_DIR/release.tar.gz" . || { 
            echo "โ mv failed"
            echo "   Source: $BUNDLE_DIR/release.tar.gz"
            echo "   Source exists: $([ -f "$BUNDLE_DIR/release.tar.gz" ] && echo 'yes' || echo 'no')"
            echo "   Current directory: $(pwd)"
            exit 1
          }
          
          # Clean up bundle directory
          rm -rf "$BUNDLE_DIR"
          
          [ -f release.tar.gz ] || { echo "โ release.tar.gz not created"; exit 1; }
          SIZE=$(du -h release.tar.gz | cut -f1)
          echo "โ Bundle created: $SIZE"

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-bundle
          path: release.tar.gz
          retention-days: 1

  deploy:
    name: "๐ Deploy to Production (Zero-Downtime)"
    runs-on: ubuntu-latest
    needs: build
    outputs:
      bundle_name: ${{ steps.upload-bundle.outputs.bundle_name }}
    steps:
      - name: Download bundle
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle
          path: .
        
      - name: Verify bundle downloaded
        run: |
          if [ ! -f release.tar.gz ]; then
            echo "โ release.tar.gz not found after download"
            echo "   Current directory: $(pwd)"
            echo "   Files in directory:"
            ls -la . || true
            exit 1
          fi
          SIZE=$(du -h release.tar.gz | cut -f1)
          echo "โ Bundle downloaded: release.tar.gz ($SIZE)"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Handle both escaped and unescaped newlines
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key  # Remove CRLF
          chmod 600 ~/.ssh/deploy_key
          
          # Validate SSH key
          grep -q "BEGIN.*PRIVATE" ~/.ssh/deploy_key || { echo "โ Invalid SSH key"; exit 1; }
          grep -q "END.*PRIVATE" ~/.ssh/deploy_key || { echo "โ SSH key missing END marker"; exit 1; }
          echo "โ SSH key valid ($(wc -c < ~/.ssh/deploy_key) bytes)"

      - name: Test SSH connection
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "echo 'โ SSH OK' && uname -a" || {
            echo "โ SSH failed - check SSH_KEY, HOST, SSH_PORT, SSH_USER"
            exit 1
          }

      - name: Upload bundle to staging
        run: |
          set -e  # Exit on any error
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          # Verify local bundle exists before uploading
          if [ ! -f release.tar.gz ]; then
            echo "โ release.tar.gz not found in current directory"
            echo "   Current directory: $(pwd)"
            ls -la . | grep -E "release|tar" || echo "   (no release files found)"
            exit 1
          fi
          
          LOCAL_SIZE=$(du -h release.tar.gz | cut -f1)
          echo "๐ฆ Local bundle verified: release.tar.gz ($LOCAL_SIZE)"
          
          # Create folders and verify they exist
          echo "๐ Creating remote folders..."
          ssh $SSH_OPTS "$SSH_USER@$HOST" "mkdir -p $DEPLOY_FOLDER $STAGING_FOLDER $BACKUP_FOLDER" || {
            echo "โ Failed to create remote folders"
            exit 1
          }
          
          # Verify folders were created
          ssh $SSH_OPTS "$SSH_USER@$HOST" "test -d $STAGING_FOLDER" || {
            echo "โ Staging folder does not exist after creation: $STAGING_FOLDER"
            exit 1
          }
          echo "โ Remote folders verified"
          
          # Generate bundle name
          TIMESTAMP=$(date +%s)
          BUNDLE_NAME="release-$TIMESTAMP.tar.gz"
          STAGING_PATH="$STAGING_FOLDER/$BUNDLE_NAME"
          
          echo "๐ฆ Uploading bundle: $BUNDLE_NAME"
          echo "   Destination: $STAGING_PATH"
          
          # Upload with verbose output
          rsync -avz --progress -e "ssh $SSH_OPTS" release.tar.gz "$SSH_USER@$HOST:$STAGING_PATH" || {
            echo "โ rsync failed"
            echo "   Source: release.tar.gz"
            echo "   Destination: $SSH_USER@$HOST:$STAGING_PATH"
            exit 1
          }
          
          # Comprehensive verification - check file exists
          echo "๐ Verifying upload (check 1/3): File existence..."
          ssh $SSH_OPTS "$SSH_USER@$HOST" "test -f $STAGING_PATH" || {
            echo "โ Upload verification failed - file not found on remote server"
            echo "   Expected path: $STAGING_PATH"
            echo "   Staging folder contents:"
            ssh $SSH_OPTS "$SSH_USER@$HOST" "ls -la $STAGING_FOLDER 2>/dev/null || echo '   (staging folder does not exist or is not accessible)'" || true
            echo "   Staging folder permissions:"
            ssh $SSH_OPTS "$SSH_USER@$HOST" "ls -ld $STAGING_FOLDER 2>/dev/null || echo '   (cannot check permissions)'" || true
            exit 1
          }
          
          # Verify file size matches
          echo "๐ Verifying upload (check 2/3): File size..."
          LOCAL_SIZE_BYTES=$(stat -f%z release.tar.gz 2>/dev/null || stat -c%s release.tar.gz 2>/dev/null || echo "0")
          REMOTE_SIZE_BYTES=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "stat -f%z $STAGING_PATH 2>/dev/null || stat -c%s $STAGING_PATH 2>/dev/null || echo '0'")
          
          if [ "$LOCAL_SIZE_BYTES" != "$REMOTE_SIZE_BYTES" ]; then
            echo "โ File size mismatch!"
            echo "   Local: $LOCAL_SIZE_BYTES bytes"
            echo "   Remote: $REMOTE_SIZE_BYTES bytes"
            exit 1
          fi
          
          # Verify file is readable
          echo "๐ Verifying upload (check 3/3): File readability..."
          ssh $SSH_OPTS "$SSH_USER@$HOST" "test -r $STAGING_PATH" || {
            echo "โ File is not readable on remote server"
            exit 1
          }
          
          REMOTE_SIZE=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "du -h $STAGING_PATH | cut -f1")
          echo "โ Bundle uploaded and fully verified: $STAGING_PATH ($REMOTE_SIZE, $REMOTE_SIZE_BYTES bytes)"
          
          # Save bundle name to remote server with verification
          echo "๐พ Saving bundle name to remote server..."
          ssh $SSH_OPTS "$SSH_USER@$HOST" "echo '$BUNDLE_NAME' > /tmp/bundle_name.txt" || {
            echo "โ Failed to save bundle name to remote server"
            exit 1
          }
          
          # Verify remote bundle name was saved
          REMOTE_BUNDLE_NAME=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "cat /tmp/bundle_name.txt 2>/dev/null | tr -d '\n\r ' || echo ''")
          if [ "$REMOTE_BUNDLE_NAME" != "$BUNDLE_NAME" ]; then
            echo "โ Remote bundle name mismatch!"
            echo "   Expected: $BUNDLE_NAME"
            echo "   Got: $REMOTE_BUNDLE_NAME"
            exit 1
          fi
          echo "โ Bundle name saved and verified on remote server: $BUNDLE_NAME"
          
          # Save bundle name locally for finalize step
          echo "$BUNDLE_NAME" > bundle_name.txt
          
          # Verify local bundle name was saved
          if [ ! -f bundle_name.txt ] || [ -z "$(cat bundle_name.txt | tr -d '\n\r ')" ]; then
            echo "โ Failed to save bundle name locally"
            exit 1
          fi
          
          LOCAL_BUNDLE_NAME=$(cat bundle_name.txt | tr -d '\n\r ')
          if [ "$LOCAL_BUNDLE_NAME" != "$BUNDLE_NAME" ]; then
            echo "โ Local bundle name mismatch!"
            echo "   Expected: $BUNDLE_NAME"
            echo "   Got: $LOCAL_BUNDLE_NAME"
            exit 1
          fi
          
          echo "โ Bundle name saved and verified locally: $BUNDLE_NAME"

      - name: Save bundle name
        id: upload-bundle
        run: |
          set -e
          
          # Read bundle name from file
          if [ ! -f bundle_name.txt ]; then
            echo "โ bundle_name.txt not found"
            exit 1
          fi
          
          BUNDLE_NAME=$(cat bundle_name.txt | tr -d '\n\r ' || echo "")
          if [ -z "$BUNDLE_NAME" ]; then
            echo "โ BUNDLE_NAME is empty in bundle_name.txt"
            echo "   File contents: '$(cat bundle_name.txt)'"
            exit 1
          fi
          
          # Verify bundle still exists on remote server
          echo "๐ Verifying bundle still exists on remote server..."
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "test -f $STAGING_FOLDER/$BUNDLE_NAME" || {
            echo "โ Bundle no longer exists on remote server!"
            echo "   Expected: $STAGING_FOLDER/$BUNDLE_NAME"
            echo "   This should not happen - bundle was just uploaded"
            exit 1
          }
          
          # Save to GitHub output for next job
          echo "bundle_name=$BUNDLE_NAME" >> $GITHUB_OUTPUT
          echo "โ Bundle name set as job output: $BUNDLE_NAME"
          echo "โ Bundle verified on remote server: $STAGING_FOLDER/$BUNDLE_NAME"
        
      - name: Upload bundle info artifact
        uses: actions/upload-artifact@v4
        with:
          name: bundle-info
          path: bundle_name.txt
          retention-days: 1
          
      - name: Final verification before job completion
        run: |
          set -e
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          BUNDLE_NAME=$(cat bundle_name.txt | tr -d '\n\r ')
          echo "๐ Final verification: Bundle and metadata..."
          
          # Verify bundle file
          ssh $SSH_OPTS "$SSH_USER@$HOST" "test -f $STAGING_FOLDER/$BUNDLE_NAME" || {
            echo "โ Final check failed: Bundle not found on remote server"
            exit 1
          }
          
          # Verify remote bundle name file
          REMOTE_BUNDLE_NAME=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "cat /tmp/bundle_name.txt 2>/dev/null | tr -d '\n\r ' || echo ''")
          if [ "$REMOTE_BUNDLE_NAME" != "$BUNDLE_NAME" ]; then
            echo "โ Final check failed: Remote bundle name mismatch"
            echo "   Expected: $BUNDLE_NAME"
            echo "   Got: $REMOTE_BUNDLE_NAME"
            exit 1
          fi
          
          echo "โ All verifications passed - bundle ready for deployment"

  finalize:
    name: "โ Finalize Deployment (Zero-Downtime Swap)"
    runs-on: ubuntu-latest
    needs: deploy
    env:
      STAGING_FOLDER: /var/www/naukrimili-staging
      DEPLOY_FOLDER: /var/www/naukrimili
      BACKUP_FOLDER: /var/www/naukrimili-backup
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      HOST: ${{ secrets.HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download bundle info
        uses: actions/download-artifact@v4
        with:
          name: bundle-info
          path: .
        
      - name: Verify bundle info downloaded
        run: |
          if [ ! -f bundle_name.txt ]; then
            echo "โ bundle_name.txt not found after download"
            echo "   Current directory: $(pwd)"
            echo "   Files in directory:"
            ls -la . || true
            echo "   Trying to get bundle name from job output..."
            # Try to get from job output as fallback
            if [ -n "${{ needs.deploy.outputs.bundle_name }}" ]; then
              echo "${{ needs.deploy.outputs.bundle_name }}" > bundle_name.txt
              echo "โ Used bundle name from job output: ${{ needs.deploy.outputs.bundle_name }}"
            else
              echo "โ Could not determine bundle name"
              exit 1
            fi
          fi
          
          BUNDLE_NAME=$(cat bundle_name.txt | tr -d '\n\r ' || echo "")
          if [ -z "$BUNDLE_NAME" ]; then
            echo "โ BUNDLE_NAME is empty in bundle_name.txt"
            echo "   File contents: '$(cat bundle_name.txt)'"
            exit 1
          fi
          
          echo "โ Bundle name loaded: $BUNDLE_NAME"
          echo "BUNDLE_NAME=$BUNDLE_NAME" >> $GITHUB_ENV

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Verify deployment script exists
        run: |
          if [ ! -f .github/scripts/deploy-remote.sh ]; then
            echo "โ Deployment script not found: .github/scripts/deploy-remote.sh"
            echo "   Current directory: $(pwd)"
            echo "   Repository files:"
            ls -la .github/scripts/ 2>/dev/null || echo "   (.github/scripts does not exist)"
            exit 1
          fi
          echo "โ Deployment script found: .github/scripts/deploy-remote.sh"
          echo "   Script size: $(stat -f%z .github/scripts/deploy-remote.sh 2>/dev/null || stat -c%s .github/scripts/deploy-remote.sh 2>/dev/null || echo 'unknown') bytes"

      - name: Deploy with zero-downtime swap
        env:
          BUNDLE_NAME: ${{ env.BUNDLE_NAME || 'unknown' }}
          STAGING_FOLDER: /var/www/naukrimili-staging
          DEPLOY_FOLDER: /var/www/naukrimili
          BACKUP_FOLDER: /var/www/naukrimili-backup
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          HOST: ${{ secrets.HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_KEY: ${{ secrets.SSH_KEY }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
        run: |
          set -e
          
          # Debug: Show all environment variables at start
          echo "๐ Debug: Environment variables check"
          echo "   STAGING_FOLDER: ${STAGING_FOLDER:-'(not set)'}"
          echo "   DEPLOY_FOLDER: ${DEPLOY_FOLDER:-'(not set)'}"
          echo "   BACKUP_FOLDER: ${BACKUP_FOLDER:-'(not set)'}"
          echo "   HOST: ${HOST:-'(not set)'}"
          echo "   SSH_USER: ${SSH_USER:-'(not set)'}"
          echo "   SSH_PORT: ${SSH_PORT:-'(not set)'}"
          
          # Export environment variables explicitly to ensure they're available
          export STAGING_FOLDER="${STAGING_FOLDER:-/var/www/naukrimili-staging}"
          export DEPLOY_FOLDER="${DEPLOY_FOLDER:-/var/www/naukrimili}"
          export BACKUP_FOLDER="${BACKUP_FOLDER:-/var/www/naukrimili-backup}"
          export HOST="${HOST}"
          export SSH_USER="${SSH_USER}"
          export SSH_PORT="${SSH_PORT}"
          export DATABASE_URL="${DATABASE_URL}"
          
          # Verify required environment variables are set
          if [ -z "$STAGING_FOLDER" ] || [ "$STAGING_FOLDER" = "" ]; then
            echo "โ STAGING_FOLDER is not set!"
            echo "   Available env vars:"
            env | grep -E "STAGING|DEPLOY|BACKUP" || echo "   (none found)"
            exit 1
          fi
          
          if [ -z "$DEPLOY_FOLDER" ] || [ "$DEPLOY_FOLDER" = "" ]; then
            echo "โ DEPLOY_FOLDER is not set!"
            echo "   Available env vars:"
            env | grep -E "STAGING|DEPLOY|BACKUP" || echo "   (none found)"
            exit 1
          fi
          
          if [ -z "$BACKUP_FOLDER" ] || [ "$BACKUP_FOLDER" = "" ]; then
            echo "โ BACKUP_FOLDER is not set!"
            echo "   Available env vars:"
            env | grep -E "STAGING|DEPLOY|BACKUP" || echo "   (none found)"
            exit 1
          fi
          
          echo "๐ Environment variables:"
          echo "   STAGING_FOLDER: $STAGING_FOLDER"
          echo "   DEPLOY_FOLDER: $DEPLOY_FOLDER"
          echo "   BACKUP_FOLDER: $BACKUP_FOLDER"
          echo "   DATABASE_URL: ${DATABASE_URL:0:30}... (hidden)"
          
          # Get bundle name from environment or file
          if [ -z "$BUNDLE_NAME" ] || [ "$BUNDLE_NAME" = "unknown" ]; then
            if [ -f bundle_name.txt ]; then
              BUNDLE_NAME=$(cat bundle_name.txt | tr -d '\n\r ' || echo "")
            fi
          fi
          
          # Final fallback - try to get from job output
          if [ -z "$BUNDLE_NAME" ]; then
            BUNDLE_NAME="${{ needs.deploy.outputs.bundle_name }}"
          fi
          
                 SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3"
          
          # Verify bundle name is not empty
          if [ -z "$BUNDLE_NAME" ]; then
            echo "โ BUNDLE_NAME is empty after all attempts!"
            echo "   Tried: environment variable, bundle_name.txt, job output"
            exit 1
          fi
          
          echo "๐ Deploying $BUNDLE_NAME with zero-downtime swap..."
          echo "โฑ๏ธ  Deployment timeout: 8 minutes (480 seconds)"
          
          # Upload remote deployment script to avoid heredoc length limit
          echo "๐ค Uploading deployment script..."
          
          # Verify script file exists
          if [ ! -f .github/scripts/deploy-remote.sh ]; then
            echo "โ Deployment script not found: .github/scripts/deploy-remote.sh"
            echo "   Current directory: $(pwd)"
            echo "   Files in .github/scripts/:"
            ls -la .github/scripts/ 2>/dev/null || echo "   (directory does not exist)"
            echo "   All .github files:"
            find .github -type f 2>/dev/null | head -20 || echo "   (no files found)"
            exit 1
          fi
          
          # Copy script file to temp location with verification
          echo "๐ Copying script to /tmp/deploy-remote.sh..."
          cp .github/scripts/deploy-remote.sh /tmp/deploy-remote.sh || {
            echo "โ Failed to copy script to /tmp/"
            echo "   Source file: $([ -f .github/scripts/deploy-remote.sh ] && echo 'exists' || echo 'missing')"
            echo "   /tmp directory writable: $([ -w /tmp ] && echo 'yes' || echo 'no')"
            exit 1
          }
          
          chmod +x /tmp/deploy-remote.sh
          echo "โ Script file copied and made executable"
          
          # Verify script file exists and is readable before upload
          if [ ! -f /tmp/deploy-remote.sh ]; then
            echo "โ Script file not found at /tmp/deploy-remote.sh after copy"
            echo "   Source file exists: $([ -f .github/scripts/deploy-remote.sh ] && echo 'yes' || echo 'no')"
            echo "   /tmp directory contents:"
            ls -la /tmp/ | grep deploy || echo "   (no deploy files found)"
            exit 1
          fi
          
          if [ ! -r /tmp/deploy-remote.sh ]; then
            echo "โ Script file is not readable: /tmp/deploy-remote.sh"
            ls -la /tmp/deploy-remote.sh || true
            exit 1
          fi
          
          echo "๐ค Uploading script to server..."
          
          # Verify SSH variables are set
          if [ -z "$HOST" ] || [ -z "$SSH_USER" ]; then
            echo "โ SSH variables not set!"
            echo "   HOST: ${HOST:-'(not set)'}"
            echo "   SSH_USER: ${SSH_USER:-'(not set)'}"
            echo "   SSH_PORT: ${SSH_PORT:-'(not set)'}"
            exit 1
          fi
          
          # Verify SSH key exists
          if [ ! -f ~/.ssh/deploy_key ]; then
            echo "โ SSH key not found: ~/.ssh/deploy_key"
            ls -la ~/.ssh/ 2>/dev/null || echo "   (~/.ssh does not exist)"
            exit 1
          fi
          
          LOCAL_SIZE=$(stat -f%z /tmp/deploy-remote.sh 2>/dev/null || stat -c%s /tmp/deploy-remote.sh 2>/dev/null || echo 'unknown')
          echo "   Local script: /tmp/deploy-remote.sh ($LOCAL_SIZE bytes)"
          echo "   Remote destination: $SSH_USER@$HOST:/tmp/deploy-remote.sh"
          
          # Test SSH connection first
          echo "๐ Testing SSH connection..."
          if ! ssh $SSH_OPTS "$SSH_USER@$HOST" "echo 'SSH connection successful'"; then
            echo "โ SSH connection test failed"
            echo "   HOST: $HOST"
            echo "   SSH_USER: $SSH_USER"
            echo "   SSH_PORT: $SSH_PORT"
            echo "   SSH key exists: $([ -f ~/.ssh/deploy_key ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          echo "โ SSH connection test passed"
          
          # Upload script to server
          echo "๐ค Executing scp upload..."
          
          # Final verification before scp
          if [ ! -f /tmp/deploy-remote.sh ]; then
            echo "โ Script file disappeared before scp: /tmp/deploy-remote.sh"
            echo "   /tmp contents:"
            ls -la /tmp/ | grep deploy || echo "   (no deploy files)"
            exit 1
          fi
          
          # scp uses -P (uppercase) for port, not -p (lowercase) like ssh
          # Use explicit flags instead of SSH_OPTS variable to avoid expansion issues
          SCP_SCRIPT="/tmp/deploy-remote.sh"
          SCP_DEST="$SSH_USER@$HOST:/tmp/deploy-remote.sh"
          
          echo "   Local file: $SCP_SCRIPT"
          echo "   Remote destination: $SCP_DEST"
          echo "   File exists check: $([ -f "$SCP_SCRIPT" ] && echo 'yes' || echo 'no')"
          echo "   File size: $(stat -f%z "$SCP_SCRIPT" 2>/dev/null || stat -c%s "$SCP_SCRIPT" 2>/dev/null || echo 'unknown') bytes"
          
          if ! scp -i ~/.ssh/deploy_key -P "$SSH_PORT" -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3 "$SCP_SCRIPT" "$SCP_DEST"; then
            echo "โ Failed to upload deployment script"
            echo "   Script file exists: $([ -f /tmp/deploy-remote.sh ] && echo 'yes' || echo 'no')"
            echo "   Script file size: $LOCAL_SIZE bytes"
            echo "   Script file readable: $([ -r /tmp/deploy-remote.sh ] && echo 'yes' || echo 'no')"
            echo "   Script file path: $(realpath /tmp/deploy-remote.sh 2>/dev/null || echo '/tmp/deploy-remote.sh')"
            echo "   Testing with absolute path:"
            ls -la /tmp/deploy-remote.sh || echo "   (cannot list file)"
            echo "   Remote directory test:"
            ssh $SSH_OPTS "$SSH_USER@$HOST" "test -w /tmp && echo 'writable' || echo 'not writable'" || echo "   (could not test)"
            echo "   Trying scp with verbose output:"
            scp -v -i ~/.ssh/deploy_key -P "$SSH_PORT" /tmp/deploy-remote.sh "$SSH_USER@$HOST:/tmp/deploy-remote.sh" 2>&1 | tail -20 || true
            exit 1
          fi
          
          # Verify script was uploaded successfully
          ssh $SSH_OPTS "$SSH_USER@$HOST" "test -f /tmp/deploy-remote.sh && echo 'โ Script uploaded successfully' || echo 'โ Script not found on remote server'" || {
            echo "โ Could not verify script upload"
            exit 1
          }
          
          # Execute remote script with environment variables
          # CRITICAL: Add timeout to prevent hanging indefinitely (reduced to 8min for faster failure detection)
          # Export all variables explicitly in the remote shell session
          echo "๐ Executing remote deployment script..."
          echo "   BUNDLE_NAME: $BUNDLE_NAME"
          echo "   STAGING_FOLDER: $STAGING_FOLDER"
          echo "   DEPLOY_FOLDER: $DEPLOY_FOLDER"
          echo "   BACKUP_FOLDER: $BACKUP_FOLDER"
          
          # Escape single quotes in variables to prevent shell injection
          BUNDLE_NAME_ESC=$(echo "$BUNDLE_NAME" | sed "s/'/'\"'\"'/g")
          STAGING_FOLDER_ESC=$(echo "$STAGING_FOLDER" | sed "s/'/'\"'\"'/g")
          DEPLOY_FOLDER_ESC=$(echo "$DEPLOY_FOLDER" | sed "s/'/'\"'\"'/g")
          BACKUP_FOLDER_ESC=$(echo "$BACKUP_FOLDER" | sed "s/'/'\"'\"'/g")
          DATABASE_URL_ESC=$(echo "$DATABASE_URL" | sed "s/'/'\"'\"'/g")
          
          # Execute with proper variable export and verification
          # Reduced timeout from 600s (10min) to 480s (8min) for faster failure detection
          timeout 480 ssh $SSH_OPTS "$SSH_USER@$HOST" \
            "export BUNDLE_NAME='$BUNDLE_NAME_ESC' && \
             export STAGING_FOLDER='$STAGING_FOLDER_ESC' && \
             export DEPLOY_FOLDER='$DEPLOY_FOLDER_ESC' && \
             export BACKUP_FOLDER='$BACKUP_FOLDER_ESC' && \
             export DATABASE_URL='$DATABASE_URL_ESC' && \
             echo '๐ Remote environment check:' && \
             echo \"   STAGING_FOLDER: \$STAGING_FOLDER\" && \
             echo \"   DEPLOY_FOLDER: \$DEPLOY_FOLDER\" && \
             echo \"   BACKUP_FOLDER: \$BACKUP_FOLDER\" && \
             echo \"   BUNDLE_NAME: \$BUNDLE_NAME\" && \
             echo \"   DATABASE_URL: \${DATABASE_URL:0:30}... (hidden)\" && \
             test -f /tmp/deploy-remote.sh || { echo 'โ Script not found on remote'; exit 1; } && \
             bash /tmp/deploy-remote.sh"
          
          # Check exit code from remote script
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 124 ]; then
              echo "โ Deployment timed out after 8 minutes"
              echo "   This usually means the deployment script is stuck or taking too long"
              echo "   Check PM2 logs and application startup time"
            else
              echo "โ Deployment failed with exit code: $EXIT_CODE"
            fi
            exit $EXIT_CODE
          fi
          
          echo "โ Deployment complete - zero downtime achieved!"

      - name: Post-deployment verification
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15"
          
          echo "๐งช Running post-deployment checks..."
          
          # Check PM2 status
          echo ""
          echo "๐ PM2 Status:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "pm2 status" || echo "โ๏ธ  Could not get PM2 status"
          
          # Check health endpoint
          echo ""
          echo "๐ฅ Health Check:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "curl -s http://localhost:3000/api/health | head -c 200 || echo 'โ๏ธ  No response'" || true
          
          # Check disk usage
          echo ""
          echo "๐พ Disk Usage:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "du -sh $DEPLOY_FOLDER $BACKUP_FOLDER 2>/dev/null || echo 'N/A'" || true
          
          echo ""
          echo "โ Post-deployment verification complete"
