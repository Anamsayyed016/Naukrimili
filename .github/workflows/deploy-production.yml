name: Deploy to Production (Zero-Downtime)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  HOST: ${{ secrets.HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  # Google OAuth removed - using manual registration only
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
  GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
  PROD_URL: https://naukrimili.com
  DEPLOY_FOLDER: /var/www/naukrimili
  STAGING_FOLDER: /var/www/naukrimili-staging
  BACKUP_FOLDER: /var/www/naukrimili-backup

jobs:
  validate_secrets:
    name: "ğŸ” Validate Secrets"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate Database URL
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "âŒ DATABASE_URL is not set!"
            exit 1
          fi
          
          # Run database validation script
          if [ -f scripts/validate-db-url.sh ]; then
            chmod +x scripts/validate-db-url.sh
            bash scripts/validate-db-url.sh
          else
            # Inline validation if script doesn't exist
            if echo "$DATABASE_URL" | grep -qiE "(127\.0\.0\.1|localhost|::1)"; then
              echo "âŒ ERROR: DATABASE_URL uses localhost"
              echo "   Current DATABASE_URL (masked): $(echo "$DATABASE_URL" | sed 's/:.*@/:***@/g')"
              echo "   In production, you must use the actual database host"
              exit 1
            fi
            if ! echo "$DATABASE_URL" | grep -qE "^postgresql://"; then
              echo "âŒ DATABASE_URL must start with postgresql://"
              exit 1
            fi
            echo "âœ… DATABASE_URL validated"
          fi
      
      - name: Validate All Required Secrets
        run: |
          set +e
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” VALIDATING ALL PRODUCTION SECRETS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          MISSING=0
          
          # Check critical deployment secrets
          [ -z "$HOST" ] && echo "âŒ HOST: MISSING" && MISSING=1 || echo "âœ… HOST: SET (${#HOST} chars)"
          [ -z "$SSH_USER" ] && echo "âŒ SSH_USER: MISSING" && MISSING=1 || echo "âœ… SSH_USER: SET"
          [ -z "$SSH_PORT" ] && echo "âŒ SSH_PORT: MISSING" && MISSING=1 || echo "âœ… SSH_PORT: SET"
          [ -z "$SSH_KEY" ] && echo "âŒ SSH_KEY: MISSING" && MISSING=1 || echo "âœ… SSH_KEY: SET (${#SSH_KEY} chars)"
          [ -z "$NEXTAUTH_SECRET" ] && echo "âŒ NEXTAUTH_SECRET: MISSING" && MISSING=1 || {
            if [ ${#NEXTAUTH_SECRET} -lt 32 ]; then
              echo "âŒ NEXTAUTH_SECRET: TOO SHORT (${#NEXTAUTH_SECRET} < 32 chars)"
              MISSING=1
            else
              echo "âœ… NEXTAUTH_SECRET: SET (${#NEXTAUTH_SECRET} chars)"
            fi
          }
          [ -z "$DATABASE_URL" ] && echo "âŒ DATABASE_URL: MISSING" && MISSING=1 || echo "âœ… DATABASE_URL: SET"
          # Google OAuth removed - using manual registration only
          
          # Check optional keys
          [ -z "$OPENAI_API_KEY" ] && echo "âš ï¸  OPENAI_API_KEY: NOT SET (optional)" || echo "âœ… OPENAI_API_KEY: SET"
          [ -z "$GEMINI_API_KEY" ] && echo "âš ï¸  GEMINI_API_KEY: NOT SET (optional)" || echo "âœ… GEMINI_API_KEY: SET"
          
          echo ""
          if [ $MISSING -eq 1 ]; then
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âŒ DEPLOYMENT BLOCKED: Missing secrets!"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“‹ SETUP INSTRUCTIONS:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Add these secrets:"
            echo ""
            echo "   HOST = srv1054971.hstgr.cloud"
            echo "   SSH_USER = root"
            echo "   SSH_PORT = 22"
            echo "   SSH_KEY = (paste complete private key)"
            echo "   NEXTAUTH_SECRET = (32+ random characters)"
            echo "   DATABASE_URL = postgresql://user:pass@host:5432/db"
            echo ""
            exit 1
          fi
          
          echo "âœ… ALL SECRETS VALIDATED"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  build:
    name: "ğŸ”¨ Build Application"
    runs-on: ubuntu-latest
    needs: validate_secrets
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm config set registry https://registry.npmjs.org/
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm ci --omit=dev --legacy-peer-deps 2>&1 | tail -5
          [ -d node_modules ] || { echo "âŒ npm install failed"; exit 1; }
          echo "âœ… Dependencies installed"

      - name: Install Prisma CLI (for build)
        run: |
          echo "ğŸ”§ Installing Prisma CLI..."
          # Install prisma from devDependencies to ensure correct version
          npm install prisma@6.18.0 --save-dev --legacy-peer-deps 2>&1 | tail -5
          # Verify prisma is installed
          [ -f node_modules/.bin/prisma ] || { echo "âŒ Prisma CLI not installed"; exit 1; }
          echo "âœ… Prisma CLI installed ($(node_modules/.bin/prisma --version 2>/dev/null || echo 'version check failed'))"

      - name: Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
        run: |
          echo "ğŸ”§ Generating Prisma Client..."
          [ -f prisma/schema.prisma ] || { echo "âŒ schema.prisma not found"; exit 1; }
          rm -rf node_modules/.prisma 2>/dev/null || true
          # Use local prisma binary to ensure correct version
          ./node_modules/.bin/prisma generate --schema=prisma/schema.prisma 2>&1 | tail -20 || {
            echo "âš ï¸  Local prisma failed, trying npx..."
            npx prisma@6.18.0 generate --schema=prisma/schema.prisma 2>&1 | tail -20
          }
          [ -d node_modules/.prisma/client ] || [ -d node_modules/@prisma/client ] || \
            { echo "âŒ Prisma client not generated"; exit 1; }
          echo "âœ… Prisma client generated"

      - name: Build Next.js
        timeout-minutes: 12
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ env.PROD_URL }}
          NEXT_PUBLIC_APP_URL: ${{ env.PROD_URL }}
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          NODE_OPTIONS: --max-old-space-size=6144
          ESLINT_NO_DEV_ERRORS: true
          # Google OAuth removed - using manual registration only
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
        run: |
          echo "ğŸ”¨ Building Next.js..."
          npm run build 2>&1 | tail -30 || {
            echo "âš ï¸  npm run build failed, trying npx next build..."
            npx next build 2>&1 | tail -30 || { echo "âŒ Build failed"; exit 1; }
          }
          
          [ -d .next ] || { echo "âŒ .next not created"; exit 1; }
          FILE_COUNT=$(find .next -type f 2>/dev/null | wc -l)
          [ "$FILE_COUNT" -gt 50 ] || { echo "âŒ .next appears empty ($FILE_COUNT files)"; exit 1; }
          echo "âœ… Build successful ($FILE_COUNT files)"

      - name: Create deployment bundle
        run: |
          echo "ğŸ“¦ Creating bundle..."
          BUNDLE_DIR="/tmp/deploy-$$"
          mkdir -p "$BUNDLE_DIR"
          
          # Copy all required files to bundle directory
          echo "ğŸ“‹ Copying files to bundle..."
          cp -r .next "$BUNDLE_DIR/" || { echo "âŒ Failed to copy .next"; exit 1; }
          find "$BUNDLE_DIR/.next" -name "*.map" -delete 2>/dev/null || true
          [ -f package.json ] && cp package.json "$BUNDLE_DIR/" || { echo "âŒ Failed to copy package.json"; exit 1; }
          [ -f package-lock.json ] && cp package-lock.json "$BUNDLE_DIR/" || true
          [ -f ecosystem.config.cjs ] && cp ecosystem.config.cjs "$BUNDLE_DIR/" || { echo "âŒ Failed to copy ecosystem.config.cjs"; exit 1; }
          [ -f next.config.mjs ] && cp next.config.mjs "$BUNDLE_DIR/" || { echo "âŒ Failed to copy next.config.mjs"; exit 1; }
          [ -d public ] && cp -r public "$BUNDLE_DIR/" || true
          [ -d prisma ] && cp -r prisma "$BUNDLE_DIR/" || true
          
          # Wait a moment to ensure all file operations are complete
          sleep 1
          
          # Verify bundle directory contents
          echo "ğŸ” Verifying bundle contents..."
          [ -d "$BUNDLE_DIR/.next" ] || { echo "âŒ .next not in bundle"; exit 1; }
          [ -f "$BUNDLE_DIR/package.json" ] || { echo "âŒ package.json not in bundle"; exit 1; }
          [ -f "$BUNDLE_DIR/ecosystem.config.cjs" ] || { echo "âŒ ecosystem.config.cjs not in bundle"; exit 1; }
          [ -f "$BUNDLE_DIR/next.config.mjs" ] || { echo "âŒ next.config.mjs not in bundle"; exit 1; }
          echo "âœ… All critical files verified in bundle"
          
          # Create tar archive from outside the directory to avoid "file changed" errors
          # Using -C flag to change directory without cd, and --warning=no-file-changed to ignore non-fatal warnings
          echo "ğŸ“¦ Creating tar archive..."
          tar --warning=no-file-changed -czf release.tar.gz -C "$BUNDLE_DIR" . || {
            echo "âš ï¸  First tar attempt failed, retrying without warning flag..."
            tar -czf release.tar.gz -C "$BUNDLE_DIR" . || { echo "âŒ tar failed"; exit 1; }
          }
          
          # Clean up bundle directory
          rm -rf "$BUNDLE_DIR"
          
          # Verify archive was created
          [ -f release.tar.gz ] || { echo "âŒ release.tar.gz not created"; exit 1; }
          SIZE=$(du -h release.tar.gz | cut -f1)
          echo "âœ… Bundle created: $SIZE"
          
          # Verify bundle contents before upload
          echo "ğŸ” Verifying bundle archive contents..."
          BUNDLE_CONTENTS=$(tar -tzf release.tar.gz 2>/dev/null | head -50)
          if [ -z "$BUNDLE_CONTENTS" ]; then
            echo "âŒ ERROR: Bundle archive appears empty or corrupted"
            exit 1
          fi
          
          # Check for critical files in archive
          echo "ğŸ“‹ Checking for critical files in archive..."
          tar -tzf release.tar.gz | grep -q "^\.next/" || { echo "âŒ ERROR: .next directory not in archive"; exit 1; }
          tar -tzf release.tar.gz | grep -q "^package\.json$" || { echo "âŒ ERROR: package.json not in archive"; exit 1; }
          tar -tzf release.tar.gz | grep -q "^ecosystem\.config\.cjs$" || { echo "âŒ ERROR: ecosystem.config.cjs not in archive"; exit 1; }
          tar -tzf release.tar.gz | grep -q "^next\.config\.mjs$" || { echo "âŒ ERROR: next.config.mjs not in archive"; exit 1; }
          
          echo "ğŸ“‹ Sample of bundle contents:"
          tar -tzf release.tar.gz | head -20
          echo "... (showing first 20 files)"
          TOTAL_FILES=$(tar -tzf release.tar.gz | wc -l)
          echo "ğŸ“Š Total files in bundle: $TOTAL_FILES"
          echo "âœ… Bundle verification complete - all critical files present"

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-bundle
          path: release.tar.gz
          retention-days: 1

  deploy:
    name: "ğŸš€ Deploy to Production (Zero-Downtime)"
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download bundle
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Handle both escaped and unescaped newlines
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key  # Remove CRLF
          chmod 600 ~/.ssh/deploy_key
          
          # Validate SSH key
          grep -q "BEGIN.*PRIVATE" ~/.ssh/deploy_key || { echo "âŒ Invalid SSH key"; exit 1; }
          grep -q "END.*PRIVATE" ~/.ssh/deploy_key || { echo "âŒ SSH key missing END marker"; exit 1; }
          echo "âœ… SSH key valid ($(wc -c < ~/.ssh/deploy_key) bytes)"

      - name: Test SSH connection
        run: |
          set -e
          echo "ğŸ§ª Testing SSH connection..."
          
          # Validate required variables
          if [ -z "$HOST" ] || [ -z "$SSH_USER" ] || [ -z "$SSH_PORT" ]; then
            echo "âŒ ERROR: Missing SSH configuration!"
            [ -z "$HOST" ] && echo "  âŒ HOST: MISSING"
            [ -z "$SSH_USER" ] && echo "  âŒ SSH_USER: MISSING"
            [ -z "$SSH_PORT" ] && echo "  âŒ SSH_PORT: MISSING"
            echo ""
            echo "ğŸ“‹ To fix:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Add these secrets:"
            echo "   HOST = srv1054971.hstgr.cloud (or your server hostname/IP)"
            echo "   SSH_USER = root (or your SSH username)"
            echo "   SSH_PORT = 22 (or your SSH port)"
            exit 1
          fi
          
          # Test network connectivity first
          echo "ğŸ” Testing network connectivity to $HOST:$SSH_PORT..."
          if ! timeout 10 bash -c "</dev/tcp/$HOST/$SSH_PORT" 2>/dev/null; then
            echo "âŒ NETWORK ERROR: Cannot reach $HOST:$SSH_PORT"
            echo ""
            echo "Possible causes:"
            echo "  1. Server is down or unreachable"
            echo "  2. Firewall blocking port $SSH_PORT"
            echo "  3. Incorrect HOST or SSH_PORT"
            echo ""
            echo "ğŸ’¡ Troubleshooting:"
            echo "  1. Verify HOST is correct: $HOST"
            echo "  2. Verify SSH_PORT is correct: $SSH_PORT"
            echo "  3. Test from your local machine:"
            echo "     ssh -p $SSH_PORT $SSH_USER@$HOST"
            exit 1
          fi
          
          echo "âœ… Network connectivity OK"
          
          # Test SSH authentication
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          echo "ğŸ” Testing SSH authentication..."
          if ssh $SSH_OPTS "$SSH_USER@$HOST" "echo 'âœ… SSH OK' && uname -a" 2>&1; then
            echo "âœ… SSH connection successful!"
          else
            SSH_EXIT=$?
            echo ""
            echo "âŒ SSH authentication failed (exit code: $SSH_EXIT)"
            echo ""
            echo "Possible causes:"
            echo "  1. SSH_KEY doesn't match the public key on the server"
            echo "  2. SSH_USER is incorrect"
            echo "  3. SSH key format is incorrect"
            echo ""
            echo "ğŸ’¡ Troubleshooting:"
            echo "  1. Verify SSH_KEY secret contains complete private key"
            echo "  2. Check server's authorized_keys:"
            echo "     ssh -p $SSH_PORT $SSH_USER@$HOST 'cat ~/.ssh/authorized_keys'"
            echo "  3. Test SSH manually from your local machine:"
            echo "     ssh -p $SSH_PORT $SSH_USER@$HOST"
            echo "  4. If local SSH works, copy that exact private key to GitHub secret SSH_KEY"
            exit 1
          fi

      - name: Upload bundle to staging
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          # Create folders
          ssh $SSH_OPTS "$SSH_USER@$HOST" "mkdir -p $DEPLOY_FOLDER $STAGING_FOLDER $BACKUP_FOLDER"
          
          # Upload
          TIMESTAMP=$(date +%s)
          BUNDLE_NAME="release-$TIMESTAMP.tar.gz"
          
          # Verify bundle exists locally before upload
          if [ ! -f "release.tar.gz" ]; then
            echo "âŒ ERROR: release.tar.gz not found locally"
            ls -la *.tar.gz || echo "No tar.gz files found"
            exit 1
          fi
          
          echo "ğŸ“¤ Uploading bundle: $BUNDLE_NAME ($(du -h release.tar.gz | cut -f1))"
          rsync -avz -e "ssh $SSH_OPTS" release.tar.gz "$SSH_USER@$HOST:$STAGING_FOLDER/$BUNDLE_NAME" || {
            echo "âŒ rsync failed"
            exit 1
          }
          
          # Get local bundle size for comparison
          LOCAL_SIZE=$(du -b release.tar.gz | cut -f1)
          echo "ğŸ“Š Local bundle size: $LOCAL_SIZE bytes"
          
          # Verify bundle was uploaded and check integrity
          echo "ğŸ” Verifying bundle on server..."
          ssh $SSH_OPTS "$SSH_USER@$HOST" "
            if [ ! -f $STAGING_FOLDER/$BUNDLE_NAME ]; then
              echo 'âŒ Bundle not found on server'
              exit 1
            fi
            REMOTE_SIZE=\$(stat -f%z $STAGING_FOLDER/$BUNDLE_NAME 2>/dev/null || stat -c%s $STAGING_FOLDER/$BUNDLE_NAME 2>/dev/null || du -b $STAGING_FOLDER/$BUNDLE_NAME | cut -f1)
            if [ -z \"\$REMOTE_SIZE\" ] || [ \"\$REMOTE_SIZE\" = '0' ]; then
              echo 'âŒ Could not get remote file size'
              exit 1
            fi
            echo \"ğŸ“Š Remote size: \$REMOTE_SIZE bytes\"
            
            # Test archive integrity
            echo 'ğŸ” Testing bundle integrity...'
            if tar -tzf $STAGING_FOLDER/$BUNDLE_NAME > /dev/null 2>&1; then
              echo 'âœ… Bundle integrity verified on server'
              # Check for critical files in bundle
              if tar -tzf $STAGING_FOLDER/$BUNDLE_NAME | grep -q '^\.next/'; then
                echo 'âœ… .next directory found in bundle'
              else
                echo 'âŒ .next directory NOT found in bundle'
                exit 1
              fi
              if tar -tzf $STAGING_FOLDER/$BUNDLE_NAME | grep -q '^package\.json$'; then
                echo 'âœ… package.json found in bundle'
              else
                echo 'âŒ package.json NOT found in bundle'
                exit 1
              fi
              if tar -tzf $STAGING_FOLDER/$BUNDLE_NAME | grep -q '^ecosystem\.config\.cjs$'; then
                echo 'âœ… ecosystem.config.cjs found in bundle'
              else
                echo 'âŒ ecosystem.config.cjs NOT found in bundle'
                exit 1
              fi
              if tar -tzf $STAGING_FOLDER/$BUNDLE_NAME | grep -q '^next\.config\.mjs$'; then
                echo 'âœ… next.config.mjs found in bundle'
              else
                echo 'âŒ next.config.mjs NOT found in bundle'
                exit 1
              fi
            else
              echo 'âŒ Bundle integrity check failed on server'
              exit 1
            fi
          " || {
            echo "âŒ Failed to verify bundle on server"
            exit 1
          }
          
          # Compare sizes (approximate check)
          REMOTE_SIZE=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "stat -f%z $STAGING_FOLDER/$BUNDLE_NAME 2>/dev/null || stat -c%s $STAGING_FOLDER/$BUNDLE_NAME 2>/dev/null || du -b $STAGING_FOLDER/$BUNDLE_NAME | cut -f1")
          if [ -n "$REMOTE_SIZE" ] && [ "$REMOTE_SIZE" != "0" ]; then
            SIZE_DIFF=$((LOCAL_SIZE - REMOTE_SIZE))
            if [ ${SIZE_DIFF#-} -gt 1000 ]; then
              echo "âš ï¸  WARNING: Size difference: local=$LOCAL_SIZE, remote=$REMOTE_SIZE (diff: $SIZE_DIFF bytes)"
            else
              echo "âœ… Bundle size matches: $REMOTE_SIZE bytes"
            fi
          fi
          
          echo "âœ… Bundle uploaded and verified: $STAGING_FOLDER/$BUNDLE_NAME"
          
          # Save bundle name for deploy step
          echo "$BUNDLE_NAME" > bundle_name.txt

      - name: Save bundle name
        uses: actions/upload-artifact@v4
        with:
          name: bundle-info
          path: bundle_name.txt
          retention-days: 1

  finalize:
    name: "âœ… Finalize Deployment (Zero-Downtime Swap)"
    runs-on: ubuntu-latest
    needs: deploy
    env:
      SSH_KEY: ${{ secrets.SSH_KEY }}
    steps:
      - name: Download bundle info
        uses: actions/download-artifact@v4
        with:
          name: bundle-info

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.SSH_KEY }}
        run: |
          set -e
          echo "ğŸ”‘ Setting up SSH key..."
          
          # Check if SSH_KEY is set
          if [ -z "$SSH_KEY" ]; then
            echo "âŒ ERROR: SSH_KEY secret is not set!"
            echo ""
            echo "ğŸ“‹ To fix:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Add or update secret named 'SSH_KEY'"
            echo "3. Paste your complete private SSH key (including BEGIN and END lines)"
            exit 1
          fi
          
          echo "âœ… SSH_KEY is set (${#SSH_KEY} characters)"
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Handle both escaped and unescaped newlines
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key  # Remove CRLF
          chmod 600 ~/.ssh/deploy_key
          
          # Validate SSH key format
          KEY_CONTENT=$(cat ~/.ssh/deploy_key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          
          # Check for BEGIN marker
          if ! echo "$KEY_CONTENT" | grep -qE "BEGIN.*PRIVATE"; then
            echo "âŒ ERROR: Invalid SSH key format - missing BEGIN marker"
            echo "Key preview (first 100 chars):"
            head -c 100 ~/.ssh/deploy_key || echo "(could not read)"
            echo ""
            echo "ğŸ’¡ Make sure your GitHub secret SSH_KEY contains the complete private key"
            echo "   including the BEGIN line: -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "   or -----BEGIN RSA PRIVATE KEY-----"
            exit 1
          fi
          
          # Check for END marker
          if ! echo "$KEY_CONTENT" | grep -qE "END.*PRIVATE"; then
            echo "âŒ ERROR: Invalid SSH key - missing END marker"
            echo "Key preview (last 100 chars):"
            tail -c 100 ~/.ssh/deploy_key || echo "(could not read)"
            echo ""
            echo "ğŸ’¡ Make sure your GitHub secret SSH_KEY includes the END line:"
            echo "   -----END OPENSSH PRIVATE KEY-----"
            echo "   or -----END RSA PRIVATE KEY-----"
            exit 1
          fi
          
          # Validate key size
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "âŒ ERROR: SSH key appears too small ($KEY_SIZE bytes)"
            echo "   Expected at least 100 bytes for a valid SSH private key"
            echo "ğŸ’¡ Your SSH key may be incomplete or corrupted."
            exit 1
          fi
          
          # Validate key with ssh-keygen if available
          if command -v ssh-keygen >/dev/null 2>&1; then
            if ssh-keygen -l -f ~/.ssh/deploy_key >/dev/null 2>&1; then
              FINGERPRINT=$(ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null | awk '{print $2}')
              echo "âœ… SSH key validated (fingerprint: $FINGERPRINT)"
            else
              echo "âš ï¸  WARNING: ssh-keygen validation failed, but continuing..."
            fi
          else
            echo "âœ… SSH key validated ($KEY_SIZE bytes)"
          fi

      - name: Deploy with zero-downtime swap
        env:
          DEPLOY_FOLDER: ${{ env.DEPLOY_FOLDER }}
          STAGING_FOLDER: ${{ env.STAGING_FOLDER }}
          BACKUP_FOLDER: ${{ env.BACKUP_FOLDER }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          set -e
          BUNDLE_NAME=$(cat bundle_name.txt)
          # SSH options with keep-alive for long-running commands
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=30 -o IdentitiesOnly=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=30 -o TCPKeepAlive=yes"
          
          echo "ğŸš€ Deploying $BUNDLE_NAME with zero-downtime swap..."
          echo "ğŸ“¦ Bundle: $BUNDLE_NAME"
          echo "ğŸ“‚ Deploy folder: $DEPLOY_FOLDER"
          echo "ğŸ“‚ Staging folder: $STAGING_FOLDER"
          
          # Pass bundle name to remote
          echo "$BUNDLE_NAME" | ssh $SSH_OPTS "$SSH_USER@$HOST" "cat > /tmp/bundle_name.txt"
          
          # Pass environment variables to remote (properly escaped)
          ssh $SSH_OPTS "$SSH_USER@$HOST" "echo \"export DEPLOY_FOLDER='$DEPLOY_FOLDER'\" > /tmp/deploy_env.sh && echo \"export STAGING_FOLDER='$STAGING_FOLDER'\" >> /tmp/deploy_env.sh && echo \"export BACKUP_FOLDER='$BACKUP_FOLDER'\" >> /tmp/deploy_env.sh && echo \"export DATABASE_URL='$DATABASE_URL'\" >> /tmp/deploy_env.sh"
          
          # Create deployment script directly on remote server
          ssh $SSH_OPTS "$SSH_USER@$HOST" 'cat > /tmp/deploy_remote.sh' << 'REMOTE_SCRIPT'
          #!/bin/bash
          set -euo pipefail
          
          # Load environment variables
          source /tmp/deploy_env.sh 2>/dev/null || {
            echo "âŒ ERROR: Failed to load environment variables"
            exit 1
          }
          
          # Verify environment variables are set
          if [ -z "$DEPLOY_FOLDER" ] || [ -z "$STAGING_FOLDER" ]; then
            echo "âŒ ERROR: Environment variables not set properly"
            echo "DEPLOY_FOLDER: $DEPLOY_FOLDER"
            echo "STAGING_FOLDER: $STAGING_FOLDER"
            exit 1
          fi
          
          # Export for child processes
          export DEPLOY_FOLDER
          export STAGING_FOLDER
          export BACKUP_FOLDER
          export DATABASE_URL
          export NODE_ENV=production
          
          # Read bundle name
          BUNDLE_NAME=$(cat /tmp/bundle_name.txt 2>/dev/null || echo "")
          
          # If bundle name not found, try to find latest bundle
          if [ -z "$BUNDLE_NAME" ]; then
            echo "âš ï¸  Bundle name not in /tmp/bundle_name.txt, searching for latest bundle..."
            if [ -d "$STAGING_FOLDER" ]; then
              BUNDLE_NAME=$(ls -t "$STAGING_FOLDER"/*.tar.gz 2>/dev/null | head -1 | xargs basename 2>/dev/null || echo "")
            fi
          fi
          
          if [ -z "$BUNDLE_NAME" ]; then
            echo "âŒ ERROR: Cannot determine bundle name"
            echo "ğŸ“‚ Checking staging folder: $STAGING_FOLDER"
            if [ -d "$STAGING_FOLDER" ]; then
              echo "ğŸ“‹ Contents of staging folder:"
              ls -la "$STAGING_FOLDER" || echo "Cannot list staging folder"
            else
              echo "âŒ Staging folder does not exist: $STAGING_FOLDER"
            fi
            exit 1
          fi
          
          STAGING_PATH="$STAGING_FOLDER/$BUNDLE_NAME"
          TEMP_DEPLOY="/var/www/naukrimili-temp-$$"
          PROD_DEPLOY="$DEPLOY_FOLDER"
          BACKUP_PATH="$BACKUP_FOLDER/backup-$(date +%s)"
          
          # Export all path variables for use throughout script
          export STAGING_PATH
          export TEMP_DEPLOY
          export PROD_DEPLOY
          export BACKUP_PATH
          
          echo "ğŸ“¦ Bundle name: $BUNDLE_NAME"
          echo "ğŸ“‚ Staging folder: $STAGING_FOLDER"
          echo "ğŸ“‚ Staging path: $STAGING_PATH"
          echo "ğŸ“‚ Temp folder: $TEMP_DEPLOY"
          
          # Verify staging folder exists
          if [ ! -d "$STAGING_FOLDER" ]; then
            echo "âŒ ERROR: Staging folder does not exist: $STAGING_FOLDER"
            echo "ğŸ“‹ Creating staging folder..."
            mkdir -p "$STAGING_FOLDER" || { echo "âŒ Failed to create staging folder"; exit 1; }
          fi
          
          # Verify bundle exists
          if [ ! -f "$STAGING_PATH" ]; then
            echo "âŒ ERROR: Bundle not found at $STAGING_PATH"
            echo "ğŸ“‹ Listing staging folder contents:"
            ls -la "$STAGING_FOLDER" || echo "Cannot list staging folder"
            echo ""
            echo "ğŸ“‹ Searching for any .tar.gz files:"
            find "$STAGING_FOLDER" -name "*.tar.gz" -type f 2>/dev/null || echo "No .tar.gz files found"
            exit 1
          fi
          
          echo "âœ… Bundle found: $STAGING_PATH ($(du -h "$STAGING_PATH" | cut -f1))"
          
          # Extract to temp folder
          echo "ğŸ“‚ Creating temp folder: $TEMP_DEPLOY"
          mkdir -p "$TEMP_DEPLOY" || { echo "âŒ Failed to create temp folder"; exit 1; }
          cd "$TEMP_DEPLOY" || { echo "âŒ Failed to cd to temp folder"; exit 1; }
          
          echo "ğŸ“¦ Extracting bundle from: $STAGING_PATH"
          if [ ! -f "$STAGING_PATH" ]; then
            echo "âŒ ERROR: Bundle file not found at $STAGING_PATH"
            echo "ğŸ“‹ Current directory: $(pwd)"
            echo "ğŸ“‹ STAGING_PATH value: $STAGING_PATH"
            exit 1
          fi
          
          # Check disk space before extraction
          echo "ğŸ’¾ Checking disk space..."
          df -h "$TEMP_DEPLOY" || df -h /var/www || df -h / || true
          AVAILABLE_SPACE=$(df "$TEMP_DEPLOY" 2>/dev/null | tail -1 | awk '{print $4}' || df /var/www 2>/dev/null | tail -1 | awk '{print $4}' || echo "unknown")
          echo "ğŸ“Š Available space: $AVAILABLE_SPACE blocks"
          
          # Verify tar file integrity and list contents
          echo "ğŸ” Verifying bundle integrity..."
          if ! tar -tzf "$STAGING_PATH" > /dev/null 2>&1; then
            echo "âŒ ERROR: Bundle file is corrupted or invalid"
            echo "ğŸ“‹ File size: $(du -h "$STAGING_PATH" 2>/dev/null || echo 'unknown')"
            echo "ğŸ“‹ File type: $(file "$STAGING_PATH" 2>/dev/null || echo 'unknown')"
            exit 1
          fi
          
          # List bundle contents before extraction
          echo "ğŸ“‹ Bundle contents (before extraction):"
          tar -tzf "$STAGING_PATH" | head -30
          BUNDLE_FILE_COUNT=$(tar -tzf "$STAGING_PATH" | wc -l)
          echo "ğŸ“Š Total files in bundle: $BUNDLE_FILE_COUNT"
          
          # Verify critical files are in bundle
          echo "ğŸ” Verifying critical files in bundle..."
          tar -tzf "$STAGING_PATH" | grep -q "^\.next/" || { echo "âŒ ERROR: .next directory not in bundle"; exit 1; }
          tar -tzf "$STAGING_PATH" | grep -q "^package\.json$" || { echo "âŒ ERROR: package.json not in bundle"; exit 1; }
          tar -tzf "$STAGING_PATH" | grep -q "^ecosystem\.config\.cjs$" || { echo "âŒ ERROR: ecosystem.config.cjs not in bundle"; exit 1; }
          tar -tzf "$STAGING_PATH" | grep -q "^next\.config\.mjs$" || { echo "âŒ ERROR: next.config.mjs not in bundle"; exit 1; }
          echo "âœ… Bundle integrity and contents verified"
          
          # Extract with timeout and progress monitoring
          echo "ğŸ“¦ Starting extraction at $(date '+%H:%M:%S')..."
          echo "â³ This may take 1-2 minutes for large bundles..."
          
          # Start a background process to monitor extraction progress
          (
            sleep 5
            COUNT=0
            while [ $COUNT -lt 60 ]; do  # Monitor for up to 5 minutes (60 * 5 seconds)
              if pgrep -f "tar.*xzf.*$BUNDLE_NAME" > /dev/null 2>&1 || pgrep -f "tar.*$STAGING_PATH" > /dev/null 2>&1; then
                FILE_COUNT=$(find . -type f 2>/dev/null | wc -l)
                echo "â³ Extraction in progress... Files: $FILE_COUNT ($(date '+%H:%M:%S'))"
              else
                # Tar process not found, might have completed
                break
              fi
              sleep 5
              COUNT=$((COUNT + 1))
            done
          ) &
          MONITOR_PID=$!
          
          # Extract with timeout (3 minutes max) and optimized settings
          # Use --use-compress-program=pigz if available for faster extraction, otherwise use standard gzip
          EXTRACT_START=$(date +%s)
          if command -v pigz >/dev/null 2>&1; then
            echo "ğŸš€ Using pigz for faster extraction..."
            timeout 180 tar --use-compress-program=pigz -xf "$STAGING_PATH" > /tmp/tar_extract.log 2>&1
          else
            echo "ğŸ“¦ Using standard gzip extraction..."
            timeout 180 tar -xzf "$STAGING_PATH" > /tmp/tar_extract.log 2>&1
          fi
          EXTRACT_EXIT=$?
          EXTRACT_END=$(date +%s)
          EXTRACT_DURATION=$((EXTRACT_END - EXTRACT_START))
          
          # Kill progress monitor
          kill $MONITOR_PID 2>/dev/null || true
          wait $MONITOR_PID 2>/dev/null || true
          
          if [ $EXTRACT_EXIT -ne 0 ]; then
            echo "âŒ Extract failed or timed out (exit code: $EXTRACT_EXIT, duration: ${EXTRACT_DURATION}s)"
            echo "ğŸ“‹ Last 50 lines of tar output:"
            tail -50 /tmp/tar_extract.log || echo "No tar log available"
            echo ""
            echo "ğŸ“‹ Bundle file: $STAGING_PATH"
            echo "ğŸ“‹ File exists: $([ -f "$STAGING_PATH" ] && echo 'yes' || echo 'no')"
            echo "ğŸ“‹ File size: $(du -h "$STAGING_PATH" 2>/dev/null || echo 'unknown')"
            echo "ğŸ“‹ Current directory: $(pwd)"
            echo "ğŸ“‹ Disk space after failure:"
            df -h "$TEMP_DEPLOY" 2>/dev/null || df -h /var/www 2>/dev/null || true
            echo "ğŸ“‹ Contents of temp folder:"
            ls -la "$TEMP_DEPLOY" 2>/dev/null | head -20 || echo "Cannot list temp folder"
            if [ $EXTRACT_EXIT -eq 124 ]; then
              echo "âŒ ERROR: Extraction timed out after 5 minutes"
            fi
            exit 1
          fi
          
          # Show extraction summary
          echo "ğŸ“Š Extraction completed in ${EXTRACT_DURATION} seconds"
          echo "âœ… Bundle extracted at $(date '+%H:%M:%S')"
          echo ""
          echo "ğŸ“Š Extracted directory structure:"
          ls -lah | head -30
          echo ""
          echo "ğŸ“Š File counts:"
          echo "   Total files: $(find . -type f 2>/dev/null | wc -l)"
          echo "   Total directories: $(find . -type d 2>/dev/null | wc -l)"
          echo ""
          echo "ğŸ“Š .next directory contents:"
          if [ -d ".next" ]; then
            ls -lah .next | head -20
            echo "   .next files: $(find .next -type f 2>/dev/null | wc -l)"
            echo "   .next directories: $(find .next -type d 2>/dev/null | wc -l)"
          else
            echo "   âŒ .next directory not found!"
          fi
          
          # Verify we're in the right directory
          echo "ğŸ“‹ Current working directory: $(pwd)"
          echo "ğŸ“‹ Expected temp folder: $TEMP_DEPLOY"
          if [ "$(pwd)" != "$TEMP_DEPLOY" ]; then
            echo "âš ï¸  WARNING: Not in expected directory, changing to $TEMP_DEPLOY"
            cd "$TEMP_DEPLOY" || { echo "âŒ Failed to cd to $TEMP_DEPLOY"; exit 1; }
          fi
          
          # Verify .next directory exists and has content
          echo "ğŸ” Verifying .next directory..."
          if [ ! -d ".next" ]; then
            echo "âŒ ERROR: .next directory not found after extraction"
            echo "ğŸ“‚ Current directory: $(pwd)"
            echo "ğŸ“‚ Contents of extracted bundle:"
            ls -la
            echo "ğŸ“‚ Searching for .next in subdirectories:"
            find . -name ".next" -type d 2>/dev/null | head -10 || echo "No .next found"
            exit 1
          fi
          
          # Verify .next has content
          NEXT_FILE_COUNT=$(find .next -type f 2>/dev/null | wc -l)
          if [ "$NEXT_FILE_COUNT" -lt 10 ]; then
            echo "âš ï¸  WARNING: .next directory has very few files ($NEXT_FILE_COUNT), might be incomplete"
            echo "ğŸ“‚ .next directory structure:"
            find .next -type d | head -20
          else
            echo "âœ… .next directory verified ($NEXT_FILE_COUNT files)"
          fi
          
          # Verify critical files exist with absolute paths
          echo "ğŸ” Verifying critical files..."
          MISSING_FILES=0
          if [ ! -f "package.json" ]; then
            echo "âŒ ERROR: package.json not found at $(pwd)/package.json"
            MISSING_FILES=1
          else
            echo "âœ… package.json found ($(du -h package.json | cut -f1))"
          fi
          
          if [ ! -f "ecosystem.config.cjs" ]; then
            echo "âŒ ERROR: ecosystem.config.cjs not found at $(pwd)/ecosystem.config.cjs"
            MISSING_FILES=1
          else
            echo "âœ… ecosystem.config.cjs found ($(du -h ecosystem.config.cjs | cut -f1))"
          fi
          
          if [ ! -f "next.config.mjs" ]; then
            echo "âŒ ERROR: next.config.mjs not found at $(pwd)/next.config.mjs"
            MISSING_FILES=1
          else
            echo "âœ… next.config.mjs found ($(du -h next.config.mjs | cut -f1))"
          fi
          
          if [ $MISSING_FILES -eq 1 ]; then
            echo "âŒ Missing critical files. Full directory listing:"
            ls -lah
            echo "ğŸ“‚ Searching for missing files:"
            find . -name "package.json" -o -name "ecosystem.config.cjs" -o -name "next.config.mjs" 2>/dev/null || echo "Files not found anywhere"
            exit 1
          fi
          echo "âœ… All critical files verified and accessible"
          
          # Check if we need to install dependencies
          # Next.js standalone mode includes node_modules, so skip npm install if present
          if [ -d ".next/standalone" ]; then
            echo "âœ… Next.js standalone mode detected - node_modules included in bundle"
            echo "ğŸ“‹ Using standalone runtime from .next/standalone"
          elif [ -d "node_modules" ]; then
            echo "âœ… node_modules already present - skipping npm install"
          elif [ -f "package-lock.json" ]; then
            echo "ğŸ“š Installing production dependencies..."
            echo "â³ Starting npm install at $(date '+%H:%M:%S')..."
            # Use --ignore-scripts to skip post-install hooks that can hang
            # Use --prefer-offline to use cache when available
            # Use --maxsockets=10 to limit concurrent downloads and reduce load
            timeout 600 npm ci --omit=dev --prefer-offline --ignore-scripts --maxsockets=10 2>&1 | tee /tmp/npm_install.log | grep -E "(added|removed|changed|error|Error)" | tail -30 || {
              echo "âš ï¸  npm ci had issues, trying npm install..."
              timeout 600 npm install --production --prefer-offline --ignore-scripts --maxsockets=10 2>&1 | tee /tmp/npm_install.log | grep -E "(added|removed|changed|error|Error)" | tail -30 || {
                echo "âŒ npm install failed"
                echo "ğŸ“‹ Last 50 lines of npm log:"
                tail -50 /tmp/npm_install.log || echo "No npm log available"
                exit 1
              }
            }
            echo "âœ… Dependencies installed at $(date '+%H:%M:%S')"
          else
            echo "âš ï¸  WARNING: No package-lock.json found and no standalone/node_modules"
            echo "   This might cause issues. Continuing anyway..."
          fi
          
          # Verify node_modules or standalone runtime exists
          if [ ! -d "node_modules" ] && [ ! -d ".next/standalone" ]; then
            echo "âŒ ERROR: No node_modules or standalone runtime found after installation"
            echo "ğŸ“‹ Listing current directory:"
            ls -la
            exit 1
          fi
          
          # Run migrations if schema changed
          if [ -f prisma/schema.prisma ]; then
            export NODE_ENV=production
            if [ -z "$DATABASE_URL" ]; then
              echo "âš ï¸  WARNING: DATABASE_URL not set, skipping migrations"
            else
              echo "ğŸ—„ï¸  Installing Prisma CLI for migrations..."
              npm install prisma@6.18.0 --save-dev --legacy-peer-deps --prefer-offline 2>&1 | tail -5 || {
                echo "âš ï¸  Prisma install failed, trying npx..."
              }
              echo "ğŸ—„ï¸  Running migrations at $(date '+%H:%M:%S')..."
              if [ -f node_modules/.bin/prisma ]; then
                timeout 120 ./node_modules/.bin/prisma migrate deploy 2>&1 | tail -10 || {
                  echo "âš ï¸  Migration had issues, but continuing..."
                }
              else
                timeout 120 npx prisma@6.18.0 migrate deploy 2>&1 | tail -10 || {
                  echo "âš ï¸  Migration had issues, but continuing..."
                }
              fi
              echo "âœ… Migrations completed at $(date '+%H:%M:%S')"
            fi
          fi
          
          # Start PM2 in temp folder to test
          echo "ğŸ§ª Testing application in temp folder..."
          pm2 delete jobportal-test 2>/dev/null || true
          
          # Set environment variables for PM2
          export NODE_ENV=production
          export DATABASE_URL="$DATABASE_URL"
          
          echo "ğŸš€ Starting PM2 test instance..."
          PM2_OUTPUT=$(pm2 start ecosystem.config.cjs --name jobportal-test --env production 2>&1)
          PM2_EXIT=$?
          echo "$PM2_OUTPUT"
          
          if [ $PM2_EXIT -eq 0 ]; then
            echo "â³ Waiting for application to start (5 seconds)..."
            sleep 5
            
            # Health check with retries (faster)
            HEALTH_CHECK_PASSED=0
            for i in {1..3}; do
              if curl -f -s --max-time 5 http://localhost:3000/api/health > /dev/null 2>&1; then
                echo "âœ… Health check passed (attempt $i/3)"
                HEALTH_CHECK_PASSED=1
                break
              else
                echo "â³ Health check attempt $i/3 failed, retrying..."
                sleep 2
              fi
            done
            
            if [ $HEALTH_CHECK_PASSED -eq 1 ]; then
              
              # Success: backup current and swap
              echo "ğŸ”„ Swapping to production..."
              pm2 delete jobportal-test 2>/dev/null || true
              
              if [ -d "$PROD_DEPLOY/.next" ]; then
                echo "ğŸ’¾ Backing up current version..."
                mkdir -p "$BACKUP_PATH"
                cp -r "$PROD_DEPLOY/.next" "$BACKUP_PATH/" || true
                cp -r "$PROD_DEPLOY/node_modules" "$BACKUP_PATH/" 2>/dev/null || true
              fi
              
              # Atomic swap
              rm -rf "$PROD_DEPLOY.old"
              [ -d "$PROD_DEPLOY" ] && mv "$PROD_DEPLOY" "$PROD_DEPLOY.old" || true
              mv "$TEMP_DEPLOY" "$PROD_DEPLOY"
              rm -rf "$PROD_DEPLOY.old" "$TEMP_DEPLOY"
              
              # Verify .next exists in production folder
              if [ ! -d "$PROD_DEPLOY/.next" ]; then
                echo "âŒ ERROR: .next directory missing after swap"
                exit 1
              fi
              
              # Start production PM2
              cd "$PROD_DEPLOY"
              pm2 delete jobportal 2>/dev/null || true
              
              # Set environment for production
              export NODE_ENV=production
              export DATABASE_URL="$DATABASE_URL"
              
              if pm2 start ecosystem.config.cjs --name jobportal --env production; then
                pm2 save --force
                sleep 3
                
                # Final health check
                if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
                  echo "âœ… Production deployment successful"
                  # Clean old backups (keep last 3)
                  cd "$BACKUP_FOLDER"
                  ls -t 2>/dev/null | tail -n +4 | xargs -r rm -rf 2>/dev/null || true
                  rm -f "$STAGING_PATH"
                else
                  echo "âŒ Production health check failed"
                  pm2 logs jobportal --lines 30 || true
                  exit 1
                fi
              else
                echo "âŒ PM2 failed, rolling back..."
                if [ -d "$BACKUP_PATH/.next" ]; then
                  cp -r "$BACKUP_PATH/.next" "$PROD_DEPLOY/" || true
                  pm2 start ecosystem.config.cjs --env production || true
                fi
                exit 1
              fi
            else
              echo "âŒ Health check failed in temp folder after 3 attempts"
              echo "ğŸ“‹ PM2 status:"
              pm2 status || true
              echo "ğŸ“‹ PM2 logs (last 50 lines):"
              pm2 logs jobportal-test --lines 50 --nostream || true
              echo "ğŸ“‹ Checking if port 3000 is in use:"
              lsof -i :3000 || netstat -tuln | grep 3000 || ss -tuln | grep 3000 || true
              pm2 delete jobportal-test 2>/dev/null || true
              rm -rf "$TEMP_DEPLOY"
              exit 1
            fi
          else
            echo "âŒ PM2 start failed (exit code: $PM2_EXIT)"
            echo "ğŸ“‹ PM2 output: $PM2_OUTPUT"
            echo "ğŸ“‹ Checking PM2 status:"
            pm2 status || true
            echo "ğŸ“‹ Checking if port 3000 is in use:"
            lsof -i :3000 || netstat -tuln | grep 3000 || ss -tuln | grep 3000 || true
            echo "ğŸ“‹ Checking ecosystem.config.cjs:"
            ls -la ecosystem.config.cjs || echo "ecosystem.config.cjs not found"
            echo "ğŸ“‹ Current directory contents:"
            ls -la | head -20
            exit 1
          fi
          else
            echo "âŒ Failed to start PM2 in temp folder"
            pm2 logs jobportal-test --lines 50 || true
            rm -rf "$TEMP_DEPLOY"
            exit 1
          fi
          REMOTE_SCRIPT
          
          # Make script executable and run it
          # SSH keep-alive options prevent connection timeout during long operations
          ssh $SSH_OPTS "$SSH_USER@$HOST" 'chmod +x /tmp/deploy_remote.sh && bash /tmp/deploy_remote.sh' || {
            echo "âŒ Remote script execution failed or timed out"
            echo "ğŸ“‹ Checking script status..."
            ssh $SSH_OPTS "$SSH_USER@$HOST" 'ls -la /tmp/deploy_remote.sh 2>/dev/null || echo "Script not found"' || true
            exit 1
          }
          
          echo "âœ… Deployment complete - zero downtime achieved!"

      - name: Post-deployment verification
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15"
          
          echo "ğŸ§ª Running post-deployment checks..."
          
          # Check PM2 status
          echo ""
          echo "ğŸ“Š PM2 Status:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "pm2 status" || echo "âš ï¸  Could not get PM2 status"
          
          # Check health endpoint
          echo ""
          echo "ğŸ¥ Health Check:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "curl -s http://localhost:3000/api/health | head -c 200 || echo 'âš ï¸  No response'" || true
          
          # Check disk usage
          echo ""
          echo "ğŸ’¾ Disk Usage:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "du -sh $DEPLOY_FOLDER $BACKUP_FOLDER 2>/dev/null || echo 'N/A'" || true
          
          echo ""
          echo "âœ… Post-deployment verification complete"
