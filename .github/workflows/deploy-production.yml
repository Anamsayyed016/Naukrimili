name: Deploy to Production (Zero-Downtime)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  HOST: ${{ secrets.HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
  GOOGLE_CLOUD_OCR_API_KEY: ${{ secrets.GOOGLE_CLOUD_OCR_API_KEY }}
  PROD_URL: https://naukrimili.com
  DEPLOY_FOLDER: /var/www/naukrimili
  STAGING_FOLDER: /var/www/naukrimili-staging
  BACKUP_FOLDER: /var/www/naukrimili-backup

jobs:
  validate_secrets:
    name: "ğŸ” Validate Secrets"
    runs-on: ubuntu-latest
    steps:
      - name: Validate All Required Secrets
        run: |
          set +e
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” VALIDATING ALL PRODUCTION SECRETS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          MISSING=0
          
          # Check critical deployment secrets
          [ -z "$HOST" ] && echo "âŒ HOST: MISSING" && MISSING=1 || echo "âœ… HOST: SET (${#HOST} chars)"
          [ -z "$SSH_USER" ] && echo "âŒ SSH_USER: MISSING" && MISSING=1 || echo "âœ… SSH_USER: SET"
          [ -z "$SSH_PORT" ] && echo "âŒ SSH_PORT: MISSING" && MISSING=1 || echo "âœ… SSH_PORT: SET"
          [ -z "$SSH_KEY" ] && echo "âŒ SSH_KEY: MISSING" && MISSING=1 || echo "âœ… SSH_KEY: SET (${#SSH_KEY} chars)"
          [ -z "$NEXTAUTH_SECRET" ] && echo "âŒ NEXTAUTH_SECRET: MISSING" && MISSING=1 || {
            if [ ${#NEXTAUTH_SECRET} -lt 32 ]; then
              echo "âŒ NEXTAUTH_SECRET: TOO SHORT (${#NEXTAUTH_SECRET} < 32 chars)"
              MISSING=1
            else
              echo "âœ… NEXTAUTH_SECRET: SET (${#NEXTAUTH_SECRET} chars)"
            fi
          }
          [ -z "$DATABASE_URL" ] && echo "âŒ DATABASE_URL: MISSING" && MISSING=1 || echo "âœ… DATABASE_URL: SET"
          
          # Check optional keys (OAuth removed - no longer required)
          [ -z "$OPENAI_API_KEY" ] && echo "âš ï¸  OPENAI_API_KEY: NOT SET (optional)" || echo "âœ… OPENAI_API_KEY: SET"
          [ -z "$GEMINI_API_KEY" ] && echo "âš ï¸  GEMINI_API_KEY: NOT SET (optional)" || echo "âœ… GEMINI_API_KEY: SET"
          
          echo ""
          if [ $MISSING -eq 1 ]; then
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âŒ DEPLOYMENT BLOCKED: Missing secrets!"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“‹ SETUP INSTRUCTIONS:"
            echo "1. Go to: https://github.com/Anamsayyed016/Naukrimili/settings/secrets/actions"
            echo "2. Add these secrets:"
            echo ""
            echo "   HOST = srv1054971.hstgr.cloud"
            echo "   SSH_USER = root"
            echo "   SSH_PORT = 22"
            echo "   SSH_KEY = (paste complete private key)"
            echo "   NEXTAUTH_SECRET = (32+ random characters)"
            echo "   DATABASE_URL = postgresql://user:pass@host:5432/db"
            echo ""
            echo "   Note: Google OAuth removed - GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET no longer required"
            echo ""
            exit 1
          fi
          
          echo "âœ… ALL SECRETS VALIDATED"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  build:
    name: "ğŸ”¨ Build Application"
    runs-on: ubuntu-latest
    needs: validate_secrets
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          set -e
          echo "ğŸ“¦ Installing dependencies..."
          
          # Configure npm
          npm config set registry https://registry.npmjs.org/
          npm config set progress false
          npm config set audit false
          npm config set fund false
          npm config set legacy-peer-deps true
          
          # Clean npm cache to avoid stale data
          npm cache clean --force 2>/dev/null || true
          
          # Check for package-lock.json version mismatches
          echo "ğŸ” Checking for lockfile issues..."
          if grep -q '"@prisma/client".*"7\.' package-lock.json 2>/dev/null && grep -q '"@prisma/client".*"6\.18\.0"' package.json 2>/dev/null; then
            echo "âš ï¸  Detected Prisma version mismatch in lockfile"
            echo "ğŸ“ Lockfile has @prisma/client@7.x but package.json requires 6.18.0"
            echo "ğŸ”„ Using npm install to resolve version conflicts..."
            rm -rf node_modules package-lock.json 2>/dev/null || true
            npm install --omit=dev --legacy-peer-deps --ignore-scripts 2>&1 || {
              echo "âŒ npm install failed, trying with force..."
              npm install --omit=dev --legacy-peer-deps --force --ignore-scripts 2>&1 || {
                echo "âŒ Installation failed"
                echo "ğŸ“‹ Last 20 lines of npm error:"
                tail -20
                exit 1
              }
            }
            echo "âœ… npm install succeeded (lockfile regenerated)"
          else
            # Try npm ci first (faster, more reliable if lockfile is valid)
            # If it fails, fall back to npm install
            echo "ğŸ”§ Attempting npm ci..."
            if npm ci --omit=dev --ignore-scripts 2>&1; then
              echo "âœ… npm ci succeeded"
            else
              echo "âš ï¸  npm ci failed, trying npm install..."
              # Remove node_modules if partial install exists
              rm -rf node_modules 2>/dev/null || true
              # Use npm install with legacy-peer-deps
              npm install --omit=dev --legacy-peer-deps --ignore-scripts 2>&1 || {
                echo "âŒ npm install failed, trying with force..."
                npm install --omit=dev --legacy-peer-deps --force --ignore-scripts 2>&1 || {
                  echo "âŒ All installation methods failed"
                  echo "ğŸ“‹ Last 20 lines of npm error:"
                  npm install --omit=dev --legacy-peer-deps --force --ignore-scripts 2>&1 | tail -20
                  exit 1
                }
              }
              echo "âœ… npm install succeeded"
            fi
          fi
          
          # Verify installation
          [ -d node_modules ] || { echo "âŒ node_modules directory not found"; exit 1; }
          
          # Check for critical packages
          [ -d node_modules/next ] || { echo "âŒ Next.js not installed"; exit 1; }
          [ -d node_modules/react ] || { echo "âŒ React not installed"; exit 1; }
          
          echo "âœ… Dependencies installed successfully"

      - name: Generate Prisma Client
        env:
          SKIP_DB_VALIDATION: true
          SKIP_POSTINSTALL: true
        run: |
          set -e
          echo "ğŸ”§ Generating Prisma Client..."
          [ -f prisma/schema.prisma ] || { echo "âŒ schema.prisma not found"; exit 1; }
          
          # Clean any existing Prisma client
          rm -rf node_modules/.prisma 2>/dev/null || true
          rm -rf node_modules/@prisma/client 2>/dev/null || true
          
          # Check if Prisma CLI is available, install if needed
          if ! command -v prisma &> /dev/null && [ ! -f node_modules/.bin/prisma ]; then
            echo "ğŸ“¦ Prisma CLI not found, installing temporarily..."
            npm install --no-save prisma@6.18.0 --legacy-peer-deps 2>&1 | tail -10 || {
              echo "âš ï¸  Failed to install Prisma CLI, trying with npx..."
            }
          fi
          
          # Generate Prisma client
          echo "âš™ï¸  Running prisma generate..."
          npx prisma@6.18.0 generate --schema=prisma/schema.prisma 2>&1 | tail -20 || {
            echo "âŒ Prisma generate failed"
            echo "ğŸ“‹ Checking Prisma installation..."
            ls -la node_modules/.bin/prisma 2>/dev/null || echo "Prisma CLI not in node_modules/.bin"
            exit 1
          }
          
          # Verify Prisma client was generated
          if [ -d node_modules/.prisma/client ] || [ -d node_modules/@prisma/client ]; then
            echo "âœ… Prisma client generated successfully"
          else
            echo "âŒ Prisma client not found after generation"
            echo "ğŸ“‹ Checking node_modules structure..."
            ls -la node_modules/.prisma 2>/dev/null || echo "No .prisma directory"
            ls -la node_modules/@prisma 2>/dev/null || echo "No @prisma directory"
            exit 1
          fi

      - name: Build Next.js
        timeout-minutes: 12
        env:
          NODE_ENV: production
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ env.PROD_URL }}
          NEXT_PUBLIC_APP_URL: ${{ env.PROD_URL }}
          DATABASE_URL: "postgresql://ci:ci@127.0.0.1:5432/ci"
          NEXT_TELEMETRY_DISABLED: 1
          SKIP_ENV_VALIDATION: 1
          SKIP_DB_VALIDATION: true
          NODE_OPTIONS: --max-old-space-size=6144
          ESLINT_NO_DEV_ERRORS: true
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
        run: |
          echo "ğŸ”¨ Building Next.js..."
          npm run build 2>&1 | tail -30 || {
            echo "âš ï¸  npm run build failed, trying npx next build..."
            npx next build 2>&1 | tail -30 || { echo "âŒ Build failed"; exit 1; }
          }
          
          [ -d .next ] || { echo "âŒ .next not created"; exit 1; }
          FILE_COUNT=$(find .next -type f 2>/dev/null | wc -l)
          [ "$FILE_COUNT" -gt 50 ] || { echo "âŒ .next appears empty ($FILE_COUNT files)"; exit 1; }
          
          # Verify critical build artifacts exist
          echo "ğŸ” Verifying build artifacts..."
          CRITICAL_FILES=(
            ".next/server/middleware-manifest.json"
            ".next/required-server-files.json"
            ".next/BUILD_ID"
          )
          
          MISSING_FILES=0
          for file in "${CRITICAL_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Missing critical file: $file"
              MISSING_FILES=$((MISSING_FILES + 1))
            else
              echo "âœ… Found: $file"
            fi
          done
          
          # Verify routes are built (check for route manifest)
          if [ -f ".next/routes-manifest.json" ]; then
            echo "âœ… Routes manifest found"
            ROUTE_COUNT=$(cat .next/routes-manifest.json 2>/dev/null | grep -o '"pages":\[' | wc -l || echo "0")
            echo "ğŸ“‹ Routes detected in manifest"
          fi
          
          # Check for static and dynamic routes
          if [ -d ".next/server/app" ]; then
            APP_ROUTES=$(find .next/server/app -name "page.js" -o -name "route.js" 2>/dev/null | wc -l)
            echo "âœ… Found $APP_ROUTES app routes"
          fi
          
          if [ -d ".next/server/pages" ]; then
            PAGE_ROUTES=$(find .next/server/pages -name "*.js" 2>/dev/null | wc -l)
            echo "âœ… Found $PAGE_ROUTES page routes"
          fi
          
          if [ "$MISSING_FILES" -gt 0 ]; then
            echo "âŒ Build verification failed: $MISSING_FILES critical files missing"
            exit 1
          fi
          
          echo "âœ… Build successful ($FILE_COUNT files, all critical artifacts present)"

      - name: Create deployment bundle
        run: |
          set -e
          echo "ğŸ“¦ Creating deployment bundle..."
          
          # Step 1: Ensure all file operations from build are complete
          echo "â³ Waiting for all file operations to complete..."
          sync  # Flush all pending writes to disk
          sleep 3  # Give extra time for any background processes
          sync  # Flush again after wait
          
          # Step 2: Verify .next directory is stable (no recent modifications)
          echo "ğŸ” Verifying .next directory is stable..."
          if [ -f .next/BUILD_ID ]; then
            BUILD_ID_TIME=$(stat -c %Y .next/BUILD_ID 2>/dev/null || stat -f %m .next/BUILD_ID 2>/dev/null || echo "0")
            CURRENT_TIME=$(date +%s)
            TIME_DIFF=$((CURRENT_TIME - BUILD_ID_TIME))
            if [ "$TIME_DIFF" -lt 5 ]; then
              echo "âš ï¸  BUILD_ID was recently modified, waiting..."
              sleep 5
              sync
            fi
          fi
          
          # Step 3: Create isolated bundle directory in /tmp (completely separate from workspace)
          BUNDLE_DIR="/tmp/deploy-bundle-$$-$(date +%s)"
          mkdir -p "$BUNDLE_DIR"
          echo "ğŸ“ Bundle directory: $BUNDLE_DIR"
          
          # Step 4: Copy all required files to bundle directory (creates snapshot)
          echo "ğŸ“‹ Copying files to bundle directory..."
          
          # Copy .next directory with all contents
          echo "  â†’ Copying .next directory..."
          cp -r .next "$BUNDLE_DIR/" || { echo "âŒ Failed to copy .next"; exit 1; }
          
          # Remove source maps to reduce bundle size (after copy, so original is untouched)
          echo "  â†’ Removing source maps..."
          find "$BUNDLE_DIR/.next" -name "*.map" -type f -delete 2>/dev/null || true
          
          # Copy configuration files
          echo "  â†’ Copying configuration files..."
          [ -f package.json ] && cp package.json "$BUNDLE_DIR/" || { echo "âŒ package.json not found"; exit 1; }
          [ -f package-lock.json ] && cp package-lock.json "$BUNDLE_DIR/" || echo "âš ï¸  package-lock.json not found (will be regenerated)"
          [ -f ecosystem.config.cjs ] && cp ecosystem.config.cjs "$BUNDLE_DIR/" || echo "âš ï¸  ecosystem.config.cjs not found"
          [ -f next.config.mjs ] && cp next.config.mjs "$BUNDLE_DIR/" || { echo "âŒ next.config.mjs not found"; exit 1; }
          
          # Copy directories
          echo "  â†’ Copying directories..."
          [ -d public ] && cp -r public "$BUNDLE_DIR/" 2>/dev/null || echo "âš ï¸  public directory not found"
          [ -d prisma ] && cp -r prisma "$BUNDLE_DIR/" 2>/dev/null || { echo "âŒ prisma directory not found"; exit 1; }
          
          # Step 5: Verify bundle directory has all required content
          echo "ğŸ” Verifying bundle contents..."
          [ -d "$BUNDLE_DIR/.next" ] || { echo "âŒ .next directory not in bundle"; exit 1; }
          [ -f "$BUNDLE_DIR/package.json" ] || { echo "âŒ package.json not in bundle"; exit 1; }
          [ -f "$BUNDLE_DIR/next.config.mjs" ] || { echo "âŒ next.config.mjs not in bundle"; exit 1; }
          [ -d "$BUNDLE_DIR/prisma" ] || { echo "âŒ prisma directory not in bundle"; exit 1; }
          
          # Step 6: Ensure all copies are flushed to disk
          echo "ğŸ’¾ Flushing file system writes..."
          sync
          sleep 1
          
          # Step 7: Create tar archive from isolated snapshot directory
          # Use --warning=no-file-changed to suppress warnings (files shouldn't change in isolated dir)
          # But still fail on actual errors
          echo "ğŸ—œï¸  Creating tar archive from snapshot..."
          cd "$BUNDLE_DIR"
          
          # Count files before tar
          FILE_COUNT=$(find . -type f | wc -l)
          echo "  â†’ Archiving $FILE_COUNT files..."
          
          # Create tar with error handling
          if tar --warning=no-file-changed -czf release.tar.gz . 2>&1; then
            echo "âœ… Tar archive created successfully"
          else
            TAR_EXIT=$?
            # Check if it's just a warning (exit code 1) or real error (other codes)
            if [ "$TAR_EXIT" -eq 1 ]; then
              echo "âš ï¸  Tar reported file changes (likely false positive in isolated dir)"
              # Verify tar file was still created
              if [ -f release.tar.gz ]; then
                echo "âœ… Tar file created despite warning"
              else
                echo "âŒ Tar file not created"
                exit 1
              fi
            else
              echo "âŒ Tar failed with exit code $TAR_EXIT"
              exit 1
            fi
          fi
          
          # Verify tar file integrity
          if [ ! -f release.tar.gz ]; then
            echo "âŒ release.tar.gz not created"
            exit 1
          fi
          
          TAR_SIZE=$(du -h release.tar.gz | cut -f1)
          echo "  â†’ Archive size: $TAR_SIZE"
          
          # Test tar file can be read
          if tar -tzf release.tar.gz > /dev/null 2>&1; then
            echo "âœ… Tar archive is valid"
          else
            echo "âŒ Tar archive is corrupted"
            exit 1
          fi
          
          cd - > /dev/null
          
          # Step 8: Move tar file to workspace root
          echo "ğŸ“¦ Moving bundle to workspace..."
          mv "$BUNDLE_DIR/release.tar.gz" . || { echo "âŒ Failed to move release.tar.gz"; exit 1; }
          
          # Step 9: Clean up bundle directory
          echo "ğŸ§¹ Cleaning up..."
          rm -rf "$BUNDLE_DIR"
          
          # Step 10: Final verification
          [ -f release.tar.gz ] || { echo "âŒ release.tar.gz not found in workspace"; exit 1; }
          FINAL_SIZE=$(du -h release.tar.gz | cut -f1)
          echo "âœ… Bundle created successfully: $FINAL_SIZE"

      - name: Stamp bundle name + persist bundle_name.txt
        run: |
          set -e
          echo "ğŸ·ï¸  Stamping bundle name..."
          
          # Ensure base tar exists
          [ -f release.tar.gz ] || { echo "âŒ release.tar.gz missing"; ls -la; exit 1; }
          
          # Generate bundle name (single source of truth for ALL later jobs)
          TIMESTAMP="$(date +%s)"
          [ -n "$TIMESTAMP" ] || { echo "âŒ Failed to generate timestamp"; exit 1; }
          
          BUNDLE_NAME="release-${TIMESTAMP}.tar.gz"
          if ! echo "$BUNDLE_NAME" | grep -qE '^release-[0-9]+\.tar\.gz$'; then
            echo "âŒ Invalid bundle name format: '$BUNDLE_NAME'"
            exit 1
          fi
          
          # Rename tar to stamped bundle name
          mv -f release.tar.gz "$BUNDLE_NAME"
          [ -f "$BUNDLE_NAME" ] || { echo "âŒ Failed to rename bundle"; ls -la; exit 1; }
          
          # Persist bundle name to file (must be non-empty)
          printf '%s\n' "$BUNDLE_NAME" > bundle_name.txt
          if [ ! -s bundle_name.txt ]; then
            echo "âŒ bundle_name.txt is empty after writing"
            ls -la
            exit 1
          fi
          
          # Verify content is readable and matches expected format
          FILE_CONTENT="$(cat bundle_name.txt | tr -d '\n\r ' | head -c 200)"
          if [ -z "$FILE_CONTENT" ]; then
            echo "âŒ bundle_name.txt is empty after reading"
            cat bundle_name.txt | od -c | head -10 || true
            exit 1
          fi
          if [ "$FILE_CONTENT" != "$BUNDLE_NAME" ]; then
            echo "âŒ bundle_name.txt mismatch"
            echo "Expected: '$BUNDLE_NAME'"
            echo "Got:      '$FILE_CONTENT'"
            exit 1
          fi
          if ! echo "$FILE_CONTENT" | grep -qE '^release-[0-9]+\.tar\.gz$'; then
            echo "âŒ bundle_name.txt content invalid format: '$FILE_CONTENT'"
            exit 1
          fi
          
          echo "âœ… Bundle name persisted: $FILE_CONTENT"
          echo "ğŸ“‹ bundle_name.txt:"
          cat bundle_name.txt

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-bundle
          path: |
            release-*.tar.gz
            bundle_name.txt
          retention-days: 1
          if-no-files-found: error

  deploy:
    name: "ğŸš€ Deploy to Production (Zero-Downtime)"
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download bundle
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle
          path: ./bundle

      - name: Verify downloaded bundle contents
        run: |
          set -e
          echo "ğŸ” Verifying downloaded deployment bundle..."
          echo "ğŸ“‹ Current working directory: $(pwd)"
          echo "ğŸ“‹ Bundle directory contents:"
          ls -la ./bundle
          
          # Verify bundle_name.txt exists and is non-empty
          if [ ! -f ./bundle/bundle_name.txt ] || [ ! -s ./bundle/bundle_name.txt ]; then
            echo "âŒ bundle_name.txt missing or empty in ./bundle"
            exit 1
          fi
          
          BUNDLE_NAME="$(cat ./bundle/bundle_name.txt | tr -d '\n\r ' | head -c 200)"
          if [ -z "$BUNDLE_NAME" ]; then
            echo "âŒ bundle_name.txt is empty after reading"
            exit 1
          fi
          if ! echo "$BUNDLE_NAME" | grep -qE '^release-[0-9]+\.tar\.gz$'; then
            echo "âŒ bundle_name.txt format invalid: '$BUNDLE_NAME'"
            exit 1
          fi
          
          # Verify tar exists with that exact name
          if [ ! -f "./bundle/$BUNDLE_NAME" ]; then
            echo "âŒ Bundle tar not found: ./bundle/$BUNDLE_NAME"
            echo "ğŸ“‹ Available release tarballs:"
            ls -la ./bundle/release-*.tar.gz 2>/dev/null || true
            exit 1
          fi
          
          echo "âœ… Bundle verified: $BUNDLE_NAME"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Handle both escaped and unescaped newlines
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key  # Remove CRLF
          chmod 600 ~/.ssh/deploy_key
          
          # Validate SSH key
          grep -q "BEGIN.*PRIVATE" ~/.ssh/deploy_key || { echo "âŒ Invalid SSH key"; exit 1; }
          grep -q "END.*PRIVATE" ~/.ssh/deploy_key || { echo "âŒ SSH key missing END marker"; exit 1; }
          echo "âœ… SSH key valid ($(wc -c < ~/.ssh/deploy_key) bytes)"

      - name: Test SSH connection
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "echo 'âœ… SSH OK' && uname -a" || {
            echo "âŒ SSH failed - check SSH_KEY, HOST, SSH_PORT, SSH_USER"
            exit 1
          }

      - name: Upload bundle to staging
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          # Create folders
          ssh $SSH_OPTS "$SSH_USER@$HOST" "mkdir -p $DEPLOY_FOLDER $STAGING_FOLDER $BACKUP_FOLDER"
          
          # Upload (bundle name is defined by build job + bundle_name.txt)
          if [ ! -f ./bundle/bundle_name.txt ] || [ ! -s ./bundle/bundle_name.txt ]; then
            echo "âŒ bundle_name.txt missing or empty (expected from build artifact)"
            ls -la ./bundle || true
            exit 1
          fi
          
          BUNDLE_NAME="$(cat ./bundle/bundle_name.txt | tr -d '\n\r ' | head -c 200)"
          if [ -z "$BUNDLE_NAME" ]; then
            echo "âŒ bundle_name.txt is empty after reading"
            exit 1
          fi
          if ! echo "$BUNDLE_NAME" | grep -qE '^release-[0-9]+\.tar\.gz$'; then
            echo "âŒ bundle_name.txt format invalid: '$BUNDLE_NAME'"
            exit 1
          fi
          
          LOCAL_TAR="./bundle/$BUNDLE_NAME"
          [ -f "$LOCAL_TAR" ] || { echo "âŒ Local tar not found: $LOCAL_TAR"; ls -la ./bundle; exit 1; }
          
          echo "âœ… Uploading bundle: $BUNDLE_NAME"
          rsync -avz -e "ssh $SSH_OPTS" "$LOCAL_TAR" "$SSH_USER@$HOST:$STAGING_FOLDER/$BUNDLE_NAME" || {
            echo "âŒ rsync failed"
            echo "ğŸ“‹ Bundle name was: $BUNDLE_NAME"
            exit 1
          }
          echo "âœ… Bundle uploaded to $STAGING_FOLDER/$BUNDLE_NAME"
          
          # Verify upload succeeded by checking file exists and has reasonable size
          echo "ğŸ” Verifying upload..."
          REMOTE_SIZE=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "stat -f%z $STAGING_FOLDER/$BUNDLE_NAME 2>/dev/null || stat -c%s $STAGING_FOLDER/$BUNDLE_NAME 2>/dev/null || echo '0'")
          LOCAL_SIZE=$(stat -f%z "$LOCAL_TAR" 2>/dev/null || stat -c%s "$LOCAL_TAR" 2>/dev/null || echo '0')
          
          if [ "$REMOTE_SIZE" -eq 0 ] || [ "$REMOTE_SIZE" -lt 1000000 ]; then
            echo "âŒ Upload verification failed: Remote file size is $REMOTE_SIZE bytes (expected > 1MB)"
            exit 1
          fi
          
          # Allow 5% size difference for compression/transfer differences
          SIZE_DIFF=$((REMOTE_SIZE - LOCAL_SIZE))
          SIZE_DIFF_PERCENT=$((SIZE_DIFF * 100 / LOCAL_SIZE))
          if [ ${SIZE_DIFF_PERCENT#-} -gt 5 ]; then
            echo "âš ï¸  Size mismatch: Local=$LOCAL_SIZE, Remote=$REMOTE_SIZE (${SIZE_DIFF_PERCENT}% difference)"
            echo "âš ï¸  Continuing anyway, but this may indicate a partial upload"
          else
            echo "âœ… Upload verified: $REMOTE_SIZE bytes (matches local: $LOCAL_SIZE bytes)"
          fi
      - name: Verify bundle persists on remote server
        run: |
          set -e
          echo "ğŸ” Verifying bundle still exists on remote server after artifact upload..."
          
          # Read bundle name
          if [ ! -f ./bundle/bundle_name.txt ] || [ ! -s ./bundle/bundle_name.txt ]; then
            echo "âŒ bundle_name.txt missing or empty in ./bundle"
            exit 1
          fi
          
          BUNDLE_NAME_CONTENT=$(cat ./bundle/bundle_name.txt | tr -d '\n\r ' | head -c 200)
          if [ -z "$BUNDLE_NAME_CONTENT" ]; then
            echo "âŒ bundle_name.txt is empty"
            exit 1
          fi
          
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          REMOTE_BUNDLE_PATH="$STAGING_FOLDER/$BUNDLE_NAME_CONTENT"
          
          echo "ğŸ“¦ Verifying bundle: $BUNDLE_NAME_CONTENT"
          echo "ğŸ“‚ Remote path: $REMOTE_BUNDLE_PATH"
          
          # Verify bundle exists
          if ! ssh $SSH_OPTS "$SSH_USER@$HOST" "[ -f '$REMOTE_BUNDLE_PATH' ]"; then
            echo "âŒ CRITICAL: Bundle file not found on remote server: $REMOTE_BUNDLE_PATH"
            echo "ğŸ“‹ This means the bundle was deleted or never uploaded correctly"
            echo "ğŸ“‹ Listing staging folder contents:"
            ssh $SSH_OPTS "$SSH_USER@$HOST" "ls -lah '$STAGING_FOLDER' 2>/dev/null | head -20" || echo "  (cannot list)"
            echo "ğŸ“‹ Looking for release bundles:"
            ssh $SSH_OPTS "$SSH_USER@$HOST" "ls -t '$STAGING_FOLDER'/release-*.tar.gz 2>/dev/null | head -5" || echo "  (no bundles found)"
            exit 1
          fi
          
          # Verify bundle size
          REMOTE_SIZE=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "stat -f%z '$REMOTE_BUNDLE_PATH' 2>/dev/null || stat -c%s '$REMOTE_BUNDLE_PATH' 2>/dev/null || echo '0'")
          if [ "$REMOTE_SIZE" -lt 1000000 ]; then
            echo "âŒ CRITICAL: Bundle on remote server is too small: $REMOTE_SIZE bytes"
            exit 1
          fi
          
          REMOTE_SIZE_HUMAN=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "du -h '$REMOTE_BUNDLE_PATH' 2>/dev/null | cut -f1" || echo "unknown")
          echo "âœ… Bundle confirmed on remote server"
          echo "ğŸ“‹ Bundle: $BUNDLE_NAME_CONTENT"
          echo "ğŸ“‹ Size: $REMOTE_SIZE_HUMAN ($REMOTE_SIZE bytes)"
          echo "ğŸ“‹ Path: $REMOTE_BUNDLE_PATH"

  finalize:
    name: "âœ… Finalize Deployment (Zero-Downtime Swap)"
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Checkout code (for deployment script)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Download deployment bundle artifact (includes bundle_name.txt)
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle
          path: ./bundle
        continue-on-error: false
          
      - name: Verify and locate bundle_name.txt
        run: |
          set -e
          echo "ğŸ” Verifying deployment-bundle artifact was downloaded..."
          echo "ğŸ“‹ Current working directory: $(pwd)"
          echo "ğŸ“‹ Current directory contents:"
          ls -la
          echo ""
          echo "ğŸ“‹ Bundle directory contents:"
          ls -la ./bundle
          echo ""
          
          BUNDLE_NAME_PATH="./bundle/bundle_name.txt"
          if [ ! -f "$BUNDLE_NAME_PATH" ]; then
            echo "âŒ bundle_name.txt not found at expected path: $BUNDLE_NAME_PATH"
            exit 1
          fi
          
          # Verify file is not empty
          if [ ! -s "$BUNDLE_NAME_PATH" ]; then
            echo "âŒ bundle_name.txt is empty"
            echo "ğŸ“‹ File path: $BUNDLE_NAME_PATH"
            echo "ğŸ“‹ File size: $(stat -f%z "$BUNDLE_NAME_PATH" 2>/dev/null || stat -c%s "$BUNDLE_NAME_PATH" 2>/dev/null || echo '0') bytes"
            echo "ğŸ“‹ File contents (hex dump):"
            cat "$BUNDLE_NAME_PATH" | od -c | head -10 || cat "$BUNDLE_NAME_PATH"
            exit 1
          fi
          
          # Read and validate content
          BUNDLE_NAME_CONTENT=$(cat "$BUNDLE_NAME_PATH" | tr -d '\n\r ' | head -c 200)
          FILE_SIZE=$(stat -f%z "$BUNDLE_NAME_PATH" 2>/dev/null || stat -c%s "$BUNDLE_NAME_PATH" 2>/dev/null || echo '0')
          
          if [ -z "$BUNDLE_NAME_CONTENT" ]; then
            echo "âŒ bundle_name.txt content is empty after reading"
            echo "ğŸ“‹ File path: $BUNDLE_NAME_PATH"
            echo "ğŸ“‹ File size: $FILE_SIZE bytes"
            echo "ğŸ“‹ File hex dump:"
            cat "$BUNDLE_NAME_PATH" | od -c | head -10
            exit 1
          fi
          
          echo "âœ… Bundle name from artifact: '$BUNDLE_NAME_CONTENT'"
          echo "âœ… Bundle name length: ${#BUNDLE_NAME_CONTENT} characters"
          echo "âœ… File size: $FILE_SIZE bytes"
          
          # Verify format
          if ! echo "$BUNDLE_NAME_CONTENT" | grep -qE '^release-[0-9]+\.tar\.gz$'; then
            echo "âš ï¸  Bundle name format unexpected: '$BUNDLE_NAME_CONTENT'"
            echo "âš ï¸  Expected format: release-<timestamp>.tar.gz"
            echo "âš ï¸  Continuing anyway, but this may cause issues..."
          else
            echo "âœ… Bundle name format valid"
          fi
          
          # SINGLE SOURCE OF TRUTH for the rest of finalize job:
          # read from artifact path once and propagate via environment.
          echo "DEPLOY_BUNDLE_NAME=$BUNDLE_NAME_CONTENT" >> "$GITHUB_ENV"
          echo "âœ… DEPLOY_BUNDLE_NAME exported for subsequent steps: $BUNDLE_NAME_CONTENT"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "$SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
          sed -i 's/\r$//' ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Ensure deployment script is executable
        run: |
          set -e
          if [ ! -f .github/scripts/deploy-remote.sh ]; then
            echo "âŒ Deployment script not found after checkout: .github/scripts/deploy-remote.sh"
            echo "ğŸ“‹ .github/scripts contents:"
            ls -la .github/scripts 2>/dev/null || true
            exit 1
          fi
          chmod +x .github/scripts/deploy-remote.sh

      - name: Verify bundle exists on remote server
        run: |
          set -e
          echo "ğŸ” Ensuring bundle exists on remote server before deployment..."
          
          # Read bundle name from single source of truth (artifact-derived env)
          if [ -z "${DEPLOY_BUNDLE_NAME:-}" ]; then
            echo "âŒ DEPLOY_BUNDLE_NAME is not set (bundle_name.txt was not loaded)"
            exit 1
          fi
          LOCAL_BUNDLE_NAME="$DEPLOY_BUNDLE_NAME"
          if [ -z "$LOCAL_BUNDLE_NAME" ]; then
            echo "âŒ bundle_name.txt is empty"
            exit 1
          fi
          
          echo "ğŸ“¦ Looking for bundle: $LOCAL_BUNDLE_NAME"
          echo "ğŸ“‚ Staging folder: $STAGING_FOLDER"
          
          # Verify local tar exists (from downloaded artifact)
          LOCAL_TAR="./bundle/$LOCAL_BUNDLE_NAME"
          if [ ! -f "$LOCAL_TAR" ]; then
            echo "âŒ Local bundle tar not found in artifact: $LOCAL_TAR"
            echo "ğŸ“‹ Bundle directory contents:"
            ls -la ./bundle || true
            exit 1
          fi
          
          LOCAL_SIZE=$(stat -f%z "$LOCAL_TAR" 2>/dev/null || stat -c%s "$LOCAL_TAR" 2>/dev/null || echo '0')
          if [ "$LOCAL_SIZE" -lt 1000000 ]; then
            echo "âŒ Local bundle tar is too small: $LOCAL_SIZE bytes (expected > 1MB)"
            exit 1
          fi
          
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes -o BatchMode=yes"
          
          # Verify staging folder exists
          echo "ğŸ” Checking staging folder..."
          if ! ssh $SSH_OPTS "$SSH_USER@$HOST" "[ -d '$STAGING_FOLDER' ]"; then
            echo "âŒ Staging folder does not exist: $STAGING_FOLDER"
            echo "ğŸ“‹ Attempting to create it..."
            ssh $SSH_OPTS "$SSH_USER@$HOST" "mkdir -p '$STAGING_FOLDER'" || {
              echo "âŒ Failed to create staging folder"
              exit 1
            }
          fi
          
          # Verify bundle file exists
          REMOTE_BUNDLE_PATH="$STAGING_FOLDER/$LOCAL_BUNDLE_NAME"
          echo "ğŸ” Checking for bundle at: $REMOTE_BUNDLE_PATH"
          
          if ! ssh $SSH_OPTS "$SSH_USER@$HOST" "[ -f '$REMOTE_BUNDLE_PATH' ]"; then
            echo "âš ï¸  Bundle not found on remote server. Re-uploading from artifact..."
            echo "ğŸ“‹ Local tar: $LOCAL_TAR ($(du -h "$LOCAL_TAR" | cut -f1), $LOCAL_SIZE bytes)"
            echo "ğŸ“‹ Target: $REMOTE_BUNDLE_PATH"
            
            # Upload from artifact so finalize can be re-run safely without re-running deploy
            if ! rsync -avz -e "ssh $SSH_OPTS" "$LOCAL_TAR" "$SSH_USER@$HOST:$REMOTE_BUNDLE_PATH"; then
              echo "âŒ rsync upload failed"
              echo "ğŸ“‹ Verifying SSH connection..."
              ssh $SSH_OPTS "$SSH_USER@$HOST" "echo 'SSH OK'" || echo "âš ï¸  SSH test failed"
              exit 1
            fi
            
            # CRITICAL: Verify the upload actually succeeded before proceeding
            echo "ğŸ” Verifying re-upload succeeded..."
            sleep 2  # Give filesystem time to sync
            REMOTE_CHECK_SIZE=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "stat -f%z '$REMOTE_BUNDLE_PATH' 2>/dev/null || stat -c%s '$REMOTE_BUNDLE_PATH' 2>/dev/null || echo '0'")
            if [ "$REMOTE_CHECK_SIZE" -lt 1000000 ]; then
              echo "âŒ CRITICAL: Re-upload verification failed. Remote file size: $REMOTE_CHECK_SIZE bytes (expected > 1MB)"
              echo "ğŸ“‹ Local size was: $LOCAL_SIZE bytes"
              echo "ğŸ“‹ Remote file may not have been written correctly"
              exit 1
            fi
            echo "âœ… Re-uploaded and verified bundle: $REMOTE_BUNDLE_PATH ($REMOTE_CHECK_SIZE bytes)"
          else
            echo "âœ… Bundle already exists on remote server: $REMOTE_BUNDLE_PATH"
          fi
          
          # Verify bundle size (always check, even if it already existed)
          REMOTE_SIZE=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "stat -f%z '$REMOTE_BUNDLE_PATH' 2>/dev/null || stat -c%s '$REMOTE_BUNDLE_PATH' 2>/dev/null || echo '0'")
          if [ "$REMOTE_SIZE" -lt 1000000 ]; then
            echo "âŒ Bundle file is too small: $REMOTE_SIZE bytes (expected > 1MB)"
            exit 1
          fi
          
          # Allow 5% size difference for transfer differences
          SIZE_DIFF=$((REMOTE_SIZE - LOCAL_SIZE))
          SIZE_DIFF_PERCENT=$((SIZE_DIFF * 100 / LOCAL_SIZE))
          if [ ${SIZE_DIFF_PERCENT#-} -gt 5 ]; then
            echo "âš ï¸  Size mismatch: Local=$LOCAL_SIZE, Remote=$REMOTE_SIZE (${SIZE_DIFF_PERCENT}% difference)"
            echo "âš ï¸  Continuing anyway, but this may indicate a partial upload"
          else
            echo "âœ… Size check OK: Local=$LOCAL_SIZE, Remote=$REMOTE_SIZE"
          fi
          
          REMOTE_SIZE_HUMAN=$(ssh $SSH_OPTS "$SSH_USER@$HOST" "du -h '$REMOTE_BUNDLE_PATH' 2>/dev/null | cut -f1" || echo "unknown")
          echo "âœ… Bundle verified on remote server"
          echo "ğŸ“‹ Bundle: $LOCAL_BUNDLE_NAME"
          echo "ğŸ“‹ Size: $REMOTE_SIZE_HUMAN ($REMOTE_SIZE bytes)"
          echo "ğŸ“‹ Path: $REMOTE_BUNDLE_PATH"

      - name: Deploy with zero-downtime swap
        run: |
          set -e
          
          # Step 1: Read bundle name once (from artifact-derived env)
          if [ -z "${DEPLOY_BUNDLE_NAME:-}" ]; then
            echo "âŒ DEPLOY_BUNDLE_NAME is not set (bundle_name.txt was not loaded)"
            exit 1
          fi
          LOCAL_BUNDLE_NAME="$DEPLOY_BUNDLE_NAME"
          
          echo "âœ… Bundle name read successfully: '$LOCAL_BUNDLE_NAME'"
          echo "âœ… Bundle name length: ${#LOCAL_BUNDLE_NAME} characters"
          
          # Verify bundle name format
          if ! echo "$LOCAL_BUNDLE_NAME" | grep -qE '^release-[0-9]+\.tar\.gz$'; then
            echo "âš ï¸  Bundle name format unexpected: $LOCAL_BUNDLE_NAME"
            echo "âš ï¸  Expected format: release-<timestamp>.tar.gz"
            echo "âš ï¸  Continuing anyway..."
          else
            echo "âœ… Bundle name format valid: $LOCAL_BUNDLE_NAME"
          fi
          
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -o IdentitiesOnly=yes"
          
          echo "ğŸš€ Deploying $LOCAL_BUNDLE_NAME with zero-downtime swap..."
          
          # Verify deployment script exists
          if [ ! -f .github/scripts/deploy-remote.sh ]; then
            echo "âŒ Deployment script not found: .github/scripts/deploy-remote.sh"
            exit 1
          fi
          
          SCRIPT_SIZE=$(stat -f%z .github/scripts/deploy-remote.sh 2>/dev/null || stat -c%s .github/scripts/deploy-remote.sh 2>/dev/null || echo '0')
          echo "âœ… Deployment script found: .github/scripts/deploy-remote.sh"
          echo "   Script size: $SCRIPT_SIZE bytes"
          
          # Upload script to remote server
          echo "ğŸ“¤ Uploading deployment script..."
          scp $SSH_OPTS .github/scripts/deploy-remote.sh "$SSH_USER@$HOST:/tmp/deploy-remote.sh" || {
            echo "âŒ Failed to upload deployment script"
            exit 1
          }
          
          # Make script executable
          ssh $SSH_OPTS "$SSH_USER@$HOST" "chmod +x /tmp/deploy-remote.sh" || {
            echo "âŒ Failed to make script executable"
            exit 1
          }
          
          # Execute remote deployment script with environment variables
          echo "ğŸš€ Executing remote deployment script..."
          ssh $SSH_OPTS "$SSH_USER@$HOST" \
            "STAGING_FOLDER='$STAGING_FOLDER' \
             DEPLOY_FOLDER='$DEPLOY_FOLDER' \
             BACKUP_FOLDER='$BACKUP_FOLDER' \
             BUNDLE_NAME='$LOCAL_BUNDLE_NAME' \
             DATABASE_URL='$DATABASE_URL' \
             bash /tmp/deploy-remote.sh" || {
            echo "âŒ Remote deployment script failed"
            exit 1
          }
          
          echo "âœ… Deployment complete - zero downtime achieved!"

      - name: Post-deployment verification
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -p $SSH_PORT -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15"
          
          echo "ğŸ§ª Running post-deployment checks..."
          
          # Check PM2 status
          echo ""
          echo "ğŸ“Š PM2 Status:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "pm2 status" || echo "âš ï¸  Could not get PM2 status"
          
          # Check health endpoint
          echo ""
          echo "ğŸ¥ Health Check:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "curl -s http://localhost:3000/api/health | head -c 200 || echo 'âš ï¸  No response'" || true
          
          # Check disk usage
          echo ""
          echo "ğŸ’¾ Disk Usage:"
          ssh $SSH_OPTS "$SSH_USER@$HOST" "du -sh $DEPLOY_FOLDER $BACKUP_FOLDER 2>/dev/null || echo 'N/A'" || true
          
          echo ""
          echo "âœ… Post-deployment verification complete"
